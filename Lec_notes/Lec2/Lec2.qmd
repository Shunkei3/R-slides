---
title: "Day 2: Data wrangling with data.table"
subtitle: "Department of Applied Economics, University of Minnesota"
author: "Shunkei Kakimoto"
format: 
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    theme: 
      - default 
      - ../slide_style/styles.scss
    fontsize: 1.5em
    callout-icon: false
    scrollable: true
    echo: false
    multiplex: true
    code-link: true
    title-slide-attributes:
      data-background-color: "#447099"
    fig-dpi: 400
    chalkboard: true
    preview-links: true
webr:
  packages: ["data.table", "dplyr", "rio", "nycflights13", "AER"]
  cell-options:
    editor-font-scale: 0.8
filters:
  - webr
---

## {.center}

### {{< fa bullseye >}} Learning Objectives

+ 1. + To be able to use the basic data wrangling skills with the `data.table` package:
+ 2. Learn how to use `%>%` operator of the `magrittr` package.

<br>

::: {.callout-note}
+ `%>%` operator is not an essential topic, but it is useful if you know it. 
:::

<br>

:::{.fragment .center}
### {{< fa asterisk >}} Reference {.center}
+ [Introduction to data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)
  + I highly recommend going through this vignette to get an understanding of the `data.table` package.
+ [Efficient reshaping using data.tables](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html)
+ [R for Data Science, Ch18: Pipes](https://r4ds.had.co.nz/pipes.html)
:::

:::{.notes}
+ Today, we will learn how to manipulate data, so called data wrangling.
  + Data wrangling is a process of cleaning and transforming raw data into a useful format for analysis, which is a crucial step in data analysis.
+ There are two popular packages in R for data wrangling: `data.table` and `dplyr`.

+ Although `dplyr` is a bit easier to learn, I will introduce `data.table` package today  because I believe, in long run, `data.table` is superior to `dplyr`.  
  + Specifically, `data.table`is faster than `dplyr` especially for large data, and memory efficient.
:::

## {{< fa list >}} Today's outline: {.center}
1. [Data manipulation with data.table](#intro-data-table)
   + [What is `data.table`?](#what-is-data-table) 
   + [General data.table syntax](#syntax-data-table) 
   + [Subset rows](#subset-rows)
   + [Select columns](#select-columns)
   + [Compute on columns](#compute-on-columns)
   + [Create a new column](#create-a-new-column)
   + [Perform aggregations by group](#perform-aggregations-by-group)
   + [Reshape datasets](#reshape-data)
   + [Merge multiple datasets](#merge-multiple-datasets)

2. [`%>%` operator](#piping)
3. [Exercise Problems](#exercise-problems)
4. [Appendix](#appendix)


# Introduction to data.table {#intro-data-table}

---

## What is `data.table`? {#what-is-data-table}

:::{.panel-tabset}

### What is it?
+ `data.table` is a package in R that provides an enhanced version of `data.frame`.
  + It is designed to be fast and memory efficient.

<br>

::: {.callout-tip title="data.table vs dplyr"}

There is another package called `dplyr` that is also popular for data wrangling. But `data.table` is much faster than `dplyr` especially for large-scale data manipulation tasks.

+ See [this](https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping) for the speed comparison of dplyr and data.table.
+ [This website](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/) compares dplyr vs data.table side by side.
  + If you already know `dplyr` syntax, this website would be helpful to understand `data.table` syntax.
:::

```{r}
#| include: false
#| eval: false
library(data.table)
library(dplyr)
```

### Before Starting

1. Let's use `flights` data, which is obtained from `nycflights13`.

```{webr-r}
#| autorun: true
# Load flights data from nycflights13 package.
flights <- nycflights13::flights
# Remove rows with missing values (just for convenience)
flights <- na.omit(flights)
# Check the class of object
class(flights)
```

<br>

2. To use the functionalities of the `data.table` package, we need to convert the data class to `data.table` class.

+ use `setDT()` function from `data.table` package to convert `data.frame` class to `data.table` class.
```{webr-r}
#| autorun: true
# Load data.table package
library(data.table)
setDT(flights) # same as, flights <- as.data.table(flights)
# Now, flights is a data.table object.
class(flights)
```
:::

:::{.notes}
+ unlike `dplyr`, you don't need to use a specific function to do a specific task.
  + `data.table` syntax is more compact and efficient than `dplyr`.
:::


## General data.table syntax {.center #syntax-data-table}

The general form of `data.table` syntax is

```{webr-r}
#| eval: false
# Don't run
DT[i, j, by]
```

+ `i`: specifies which rows to be subsetted
+ `j`: specifies the operations on selected columns
+ `by`: specifies the variable to be used as groups by which operations specified in `j` are implemented


<br>

**Simply put,**

[Take data.table (named `DT`), subset/reorder rows using `i`, then calculate `j`, grouped by `by`.]{style="color: red;"}

<br>

::: {.callout-tip title="Note"}
+ You can do lots of tasks by combining `i`, `j`, and `by` arguments!
+ This is a stark difference from `dplyr` package, which requires you to use a specific function for a specific task.
:::

## {.center}

Using data.table syntax, we will see how to:

+ subset rows
+ select columns, compute on the selected columns, create a new column
+ perform aggregations by group



## 1. Subset Rows {#subset-rows}

:::{.panel-tabset}

### Basics

+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [To subset rows, use condition in `i`  expression. (e.g., `DT[colA == condition1,]`)]{style="color: blue;"}

**Example**

Let's subset rows where `carrier` is "AA" (American Airlines)

```{webr-r}
flights[carrier == "AA",] # a comma after the condition is not required
```

<br>

::: {.callout-note}
## In this code, we used:
+ `i`: to subset rows with `origin == "JFK" & month == 6L`
+ `j`: no action (all columns)
+ `by`: no action (no grouping)
:::


:::{.notes}
+ So, `i` argument does any task related to rows. 
:::


### Your Turn


<!-- start panel:your turn   --> 
:::{.panel-tabset} 
### Quiz
```{webr-r}
# 1. Subset rows where carrier is "AA" and month is 1 (January)

# 2. Subset rows where carrier is "AA" and origin is all the airports except "JFK"

# 3. Subset rows where delay in departure is less than 0 or delay in departure is less than 0. (Hint: use | for "or" condition)

```

### Answers

```{webr-r}
# 1. Subset rows where carrier is "AA" and month is 1 (January)
flights[carrier == "AA" & month == 1,]

# 2. Subset rows where carrier is "AA" and origin is all the airports except "JFK"
flights[carrier == "AA" & origin != "JFK",]

# 3. Subset rows where delay in departure is less than 0 or delay in departure is less than 0. (Hint: use | for "or" condition)
flights[dep_delay < 0 | arr_delay < 0,]
```

<!-- end panel:your turn  --> 
:::

:::


## Please Note

The important thing to remember is that you do any tasks related to rows in `i`.

<br>

**Example**

Sort `flights` first by `month` in ascending order, and then by `day` in descending order:

```{webr-r}
flights[order(month, -day)]
```





## 2. Select Columns {#select-columns}

:::{.panel-tabset}

### Basics

+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [To select columns, use `j` argument]{style="color: blue;"}.

**Example**: Suppose we want to select `dep_time` column. Since we don't subset rows, we leave `i` argument blank.

```{webr-r}
# --- Select dep_time column as vector --- #
flights[, dep_time]
# --- Select dep_time column as data.table --- #
flights[, list(dep_time)]
# or
flights[, .(dep_time)]
# or you can also select a column in the data.frame way
flights[, "dep_time"]
```

<br>

::: {.callout-note}
+ If we wrap the variables (column names) within `list()`, which ensures that a `data.table` is returned.
+ `.()` is a shorthand for `list()` in `data.table` syntax.

+ **Important**: [In data.table, each column is internally defiled as a list. As long as you use `.()` (or `list()`) in `j` expression, each element of the list will be converted to a column and results in the resulting data.table.]{style="color: red;"}
:::

<br>

### Multiple columns

You can select multiple columns just like you did to select a single column.

```{webr-r}
# --- Select dep_time and arr_time as data.table --- #
flights[, .(dep_time, arr_time)]

# --- Unselect columns using - or ! --- #
flights[, !c("dep_time", "arr_time")]
# or
# flights[, -c("dep_time", "arr_time")]
```

### Your Turn

```{webr-r}
# 1. Select year, month, day, and carrier columns as data.table.

```

:::


## 3. Compute on Columns {#compute-on-columns}

:::{.panel-tabset}

### Basics
+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [`j` not only allows you to select columns but also to compute on columns]{style="color: blue;"}.


<br>

**Example**

Let's count the number of trips which have had total delay < 0 (i.e., total day = `dep_delay` + `arr_delay`). 

```{webr-r}
# count the number of trips with total delay < 0
flights[, sum((arr_delay + dep_delay) < 0)] #Let's explore what's going on here. 
```

::: {.callout-note}
## In this code, we used:
+ `i`: no action (all rows)
+ `j`: to take the sum of the logical vector `arr_delay + dep_delay < 0`
+ `by`: no action (no grouping)

[Since, we skip the `i` expression, you need to put a comma before `j` expression.]{style="color: red;"}
:::


:::{.notes}

+ What if we want to calculate something using columns of the data?
+ In the example, three calculations are being performed in the `j` argument:

+ 1. compute `arr_delay + dep_delay`
+ 2. compute `arr_delay + dep_delay < 0`
+ 3. compute `sum(arr_delay + dep_delay < 0)`
:::

:::

## 3. Compute on Columns (continued)

:::{.panel-tabset}

### Basics

+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [Using `i` and `j` expressions together, you can perform calculations on the selected columns of the subsetted rows.]{style="color: blue;"}

<br>

**Example** 

How many flights were there with “JFK” as the origin airport in June?

```{webr-r}
flights[origin == "JFK" & month == 6L, .N]
# NOTE: `.N` is a special variable that holds the number of rows in the current group.
# So, this code is equivalent to:
# nrow(flights[origin == "JFK" & month == 6L,])
```

<br>

::: {.callout-note}
## In this code, we used:

+ `i` : to select rows where origin airport equals “JFK”, and month equals 6.
+ `j` : to count the number of rows in the subsetted data.
+ `by : no action (no grouping)
:::

### Multiple outputs

+ [You can provide names to the value we calculated if you want.]{style="color: blue;"}
+ Recall that `.()` is a shorthand for `list()` in data.table syntax (see [this slide](#select-columns)). You can name multiple elements like you name each element in the list object. 

<br>

**Example**

How many flights were there with “JFK” as the origin airport in June, and what is the average departure delay?

```{webr-r}
flights[origin == "JFK" & month == 6L, .(Count = .N, avg_dep_delay = mean(dep_delay))]
```


### Your Turn

:::{.panel-tabset}

### Quiz
1. Calculate the average arrival and departure delays for all flights with "JFK" as the origin airport in the month of August.

+ Hint: 
  + you only need to use the following variables: `origin`, `month`, `arr_delay`, `dep_delay` 
  + to calculate the average, use `mean()` function.

<br>

```{webr-r}
# You can write your code here
```

### Answers

1. Calculate the average arrival and departure delay for all flights with "JFK" as the origin airport in the month of August.
```{webr-r}
flights[origin == "JFK" & month == 8L, .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]
```
:::

:::

## 4. Create a New Column {#create-a-new-column}

:::{.panel-tabset}

### Basics

+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [In `j` expression, you can add a new column to an existing data table using `:=` operator.]{style="color: blue;"}
  + Here, `:` represents the fixed values and `=` represents the assignment of values. So, they together represent the assignment of fixed values.


<br>

**Syntax**

```r
# === Add one column === #
DT[, "new_column_name" := .(valueA)]

# or you can drop the quotes and `.()` for convenience
DT[, new_column_name := valueA]
```


### Example

Using the following simple example dataset, let's create another column `c` by adding `a` and `b` column.

```{webr-r}
# === Simple dataset === #
simple_data <- data.table(a = 1:5, b = 6:10)

# === Create a new column === #
simple_data[, "c" := .(a + b)]

# or simply, you can do 
simple_data[, c := a + b]
```


<br>

::: {.callout-important title="Important Rule:"}
`:=` creates new columns by updating the data in-place (by reference). Thus, the original data is altered.
:::

:::


## 4. Create a New Column (continued)

:::{.panel-tabset}

### Multiple New Columns

Here is how you define multiple variables at the same time.

```{webr-r}
#| autorun: false

# === Newly add two columns (formal syntax)  === #
simple_data[, c("c", "d") := .(a + b, a - b)]

# Simplified version
simple_data[, `:=`(
  c = a + b,
  d = a - b
)]
```


### Please Note

::: {.callout-caution}

+ data.table's `:=` operator doesn't allow referencing recently-added/changed variables within the same `[`-expression. To do what you want, you need another `[`.


**Example**

+ Let's create new columns: (1) `c` by adding `a` and `b`, and (2) `d` by dividing `c` by `a`.

```{webr-r}
#| eval: false

# This code does not work
flights[, `:=`(
  c = a + b,
  d = c/a,
]

# Instead do this 
flights[, c := a + b]
flights[, d := c/a]
```
:::


### Selective Update

[Using `i` and `j` expressions together, you can change the column values for rows that satisfy certain conditions.]{style="color: blue;"}


<br>

**Example:** 

```{webr-r}
#| autorun: true

# === Create a simple data === #
simple_data <- data.table(a = 1:5, b = 6:10)

# === Update column b by adding 10 only for the rows with a >= 3  === #
simple_data[a >= 3, b := b + 10]
```



<br>

::: {.callout-tip title="Tip: copy() function"}
+ If you want to keep the original data, you can create a copy of the dataset using `data.table::copy()` function.

+ The object created by copy() is independent of the original dataset in the sense that actions on one of them do not affect the other.

:::


### Quiz

:::{.panel-tabset}

### Quiz

Create two new columns in the `flights` data: 

+ `total_delay`:the sum of `dep_delay` and `arr_delay`.
+ `speed`: the ratio of `distance` to `air_time` (i.e,  `distance/air_time`.)

```{webr-r}
# You can write your code here

```

### Answers

```{webr-r}
#| autorun: true

# === Detailed version === #
flights[, c("total_delay", "speed") := .(dep_delay + arr_delay, distance / air_time)]

# === Simplified version (I use htis) === #
flights[, `:=`(
  total_delay = dep_delay + arr_delay,
  speed = distance / air_time
)]
```
:::

:::



## 5. Perform Aggregations by Group (Grouped Operations) {#perform-aggregations-by-group}


:::{.panel-tabset}

### Basics  

+ [`data.table` syntax: `DT[i, j, by]`]{style="color: blue;"}
+ [To perform grouped operations, use `by` argument.]{style="color: blue;"}
```{r}
#| eval: false
DT[, .(new_column = function(column)), by = .(group_variable)]
```

<br>


**Example**: Let's find the number of flights by `origin`.
```{webr-r}
flights[, .(.N), by = .(origin)]
```

<br>

::: {.callout-note}
## In this code, we used

+ `i`: no action (all rows) 
+ `j`: count the number of rows in each group defined by `by` argument
+ `by`: group the data by `origin`
:::



###  Group by Multiple Columns

Nothing special. Just provide multiple columns to `by` argument.

<br>

**Example**: Find the average time of departure delay and arrival delay by `carrier` and `origin`.
```{webr-r}
flights[, .(avg_dep_delay = mean(dep_delay), avg_arr_delay = mean(arr_delay)), by = .(carrier, origin)]
```


### Grouped Operations for Select Observations

[Together with `i` argument, you can perform grouped operations for select observations.]{style="color: blue;"}

<br>

**Example 1**: Get the number of flights for each origin airport for carrier code "AA" (American Airlines).
```{webr-r}
flights[carrier == "AA", .N, by = .(origin)]
```

::: {.callout-note}
+ `i`: subset rows where `carrier` is "AA"
+ `j`: count the number of rows in each group defined by `by` argument
+ `by`: group the data by `origin`
:::

<br>

**Example 2**: Find the number of flights by `origin` and `month` for carrier code "AA" (American Airlines).
```{webr-r}
flights[carrier == "AA", .N, by = .(origin, month)] %>% head()
```


### Your Turn

:::{.panel-tabset}

### Quiz

1. For each `month` and each `carrier`, calculate the total number of flights, average departure delay, and average arrival delay.


```{webr-r}
# You can write your code here

```

<br>

2. (Optional) Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov) and summarize the total number of flights, average departure delay, and average arrival delay for each season and each carrier.


```{webr-r}
# You can write your code here

```


### Answers

1. For each month and each carrier, calculate the total number of flights, average departure delay, and average arrival delay.
.

```{webr-r}
flights[,.(
  n_flights = .N,
  avg_dep_delay = mean(dep_delay),
  avg_arr_delay = mean(arr_delay)
), by = .(month, carrier)]
```

<br>

2. (Optional) Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov) and summarize the total number of flights, average departure delay, and average arrival delay for each season and each carrier.

Note: I used `fcase()` function of `data.table` package to define seasons. `fcase()` is like `case_when()` in `dplyr`. It is useful when you want to define a variable that takes different values based on conditions.


```{webr-r}
# --- Define season --- #
flights[,season := fcase(
  month %in% c(12, 1, 2), "Winter",
  month %in% c(3, 4, 5), "Spring",
  month %in% c(6, 7, 8), "Summer",
  default = "Fall" #otherwise, "Fall`"
)]

# --- Summarize by season and carrier --- #
flights[, .(
  total_flights = .N,
  avg_dep_delay = mean(dep_delay, na.rm = TRUE),
  avg_arr_delay = mean(arr_delay, na.rm = TRUE)
), by = .(season, carrier)]
```

:::
:::

:::{.notes}
+ In words, this code is saying, "Take the `flights` data, make groups by `origin`, and count the number of rows in each group.
:::


## Summary {.center}

Until now, we have learned the basic operations of the `data.table` package. 

Don't mind the details. Here are the things that I want you to know:

+ The general data.table syntax: `DT[i, j, by]`. `i` for rows, `j` for columns, and `by` for groups.
+ Any tasks related to rows can be done in `i` expression. 
  + You can subset rows by specifying conditions in `i` expression.
+ Any tasks related to columns can be done in `j` expression.
  + You can select rows, compute on columns (don't forget to use `.()`), and create new columns with `:=`.
+ Finally, you can perform grouped operations by specifying group in `by` argument. 


<br>

[With these skills, you can do many tasks related to data manipulation with the `data.table` package.]{style="color: blue;"}

## {.center}

Next, we will see a few advanced topics: Reshaping Data and Merging Multiple Datasets (and the `%>%` operator if we have time).


## 6. Reshape Data {#reshape-data}

:::{.panel-tabset}


### Basics

[Data often comes in two formats: wide or long.]{style="color: blue;"}


**Example:**

::: {.columns}

::: {.column width="50%"}
**Long data**: 

Here, each state (observational unit) is repeated several times in the first column. 

```{r}
#| echo: false

library(data.table)
library(dplyr)

yield_data_long <- 
  data.table(
    state = c("Kansas", "Nebraska", "Iowa", "Illinois") %>% rep(each = 2),
      year = c(2019, 2020) %>% rep(4),
      yield = c(200, 240, 210, 220, 220, 230, 190, 150),
      rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  )

yield_data_long
```

:::

::: {.column width="50%"}
**Wide data**

Here, each state (observational unit) appears only once in the first column, and their annual record of yield and rainfall are spread across the columns.


```{r}
#| echo: false
yield_data_wide <- 
  dcast(yield_data_long, state ~ year, value.var = c("yield", "rainfall"))

yield_data_wide
```
:::

:::

<br>

+ We can convert one format to another using `dcast()` and `melt()` functions of `data.table` package.

### Preparation

Let's use the following small dataset to understand how `dcast()` and `melt()` work.

```{webr-r}
#| autorun: true
yield_data_long <- 
  data.table(
    state = c("Kansas", "Nebraska", "Iowa", "Illinois") %>% rep(each = 2),
      year = c(2019, 2020) %>% rep(4),
      yield = c(200, 240, 210, 220, 220, 230, 190, 150),
      rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  )
```


### long to wide

+ [Use `dcast()` function converts long form to wide form]{style="color: blue;"}

**Basic Syntax:**
```{r}
#| eval: false
dcast(data, LHS ~ RHS , value.var = c("var1", "var2"))
```
+ `LHS`: set of id variables (variables (columns) that you don’t want change).
+ `RHS`: set of variables to be used as the column index.
+ `value.var`: set of variables whose values will be filled to cast.

<br>

**Example:**

Suppose that  we want to collect all yield and rainfall observations corresponding to each state under the same row. 


```{webr-r}
#| autorun: true
yield_data_wide <- dcast(yield_data_long, state ~ year , value.var = c("yield", "rainfall"))
yield_data_wide
```

<br>

::: {.callout-tip}
+ Before writing your code to reshape the data, it is important to imagine what your desired data format looks like.
+ I often sketch out an example.
  + This helps me to understand what variables I need to use as `LHS`, `RHS`, and `value.var`.
:::


### wide to long

+ [Use `melt()` function to convert wide form to long form]{style="color: blue;"}

**Basic Syntax**:
```{r}
#| eval: false
melt(data, id.var = c("id_var1", "id_var2"), measure.vars = c("var1", "var2"))
```
+ `id.vars`: the set of id variables (variables (columns) that you don’t want change).
+ `measure.vars`: the set of columns you want to collapse (or combine) together.
+ `value.name`: (optional) the name of the new column that will store the values of the variables in `measure.vars`, the default is `value`

<br>

**Example:**

Let's get back to the original data format `yield_data_long` from `yield_data_wide`.

```{webr-r}
# yield columns
col_yields <- paste0("yield_", 2019:2020)
# rainfall columns
col_rainfalls <- paste0("rainfall_", 2019:2020)

yield_data_long_2 <- 
  melt(
    yield_data_wide, 
    id.vars = "state", 
    measure.vars = list(col_yields, col_rainfalls), 
    value.name = c("yield", "rainfall")
  )

yield_data_long_2

# If you are familiar with regular expressions, you can do:
# melt(yield_data_wide, id.vars = "state", measure.vars = patterns("^yield", "^rainfall"), value.name = c("yield", "rainfall"))
```

Note however that year information from the variable names are lost. In the resulting dataset, variable == 1 and variable == 2 correspond to 2019 and 2020, respectively. So, you need an additional step to recover the original long data format.


### When to reshape data?

In my personal experience, I often need to reshape data when:

**1. I want to aggregate and summarize data efficiently.**

+ Example: `yield_data_long` is easier to calculate the average yield and rainfall by state than `yield_data_wide`.
  
```{webr-r}
# --- using long-form --- #
yield_data_long[,.(
  avg_yield = mean(yield),
  avg_rainfall = mean(rainfall)
  ), by = .(state)]

# --- using wide-form --- #
yield_data_wide[,`:=`(
  avg_yield = sum(yield_2019 + yield_2020)/2,
  avg_rainfall = sum(rainfall_2019 + rainfall_2020)/2
)]
yield_data_wide[,.(state, avg_yield, avg_rainfall)]
```

<br>

**2. I want to visualize data efficiently.**

+ We will see some examples when we learn data visualization with `ggplot2` package.

### Your Turn

:::{.panel-tabset}

### Quiz (difficult)

Using the following long-form data named `long_dt`, can you get `yield_data_long`?

```{webr-r}
# === create long_dt (run this code) === #
yield_data_wide <- dcast(yield_data_long, state ~ year, value.var = c("yield", "rainfall"))
long_data <- melt(yield_data_wide, id.var = "state")
```

<br>

```{webr-r}
# You can write your code here
```


### Answers

```{webr-r}
# First, I would create two columns: `year` and `type` (to denote year or rainfall) by splitting the `variable` column of long_data.
# use `tstrsplit()` function to split the variable column by "_"
long_data[, c("type", "year") := tstrsplit(variable, "_", fixed = TRUE)]

# Now, I don't need the variable column. So, remove it.
long_data[, variable := NULL]


# Finally, I would cast the data to the original long form.
dcast(long_data, state + year ~ type, value.var = "value")
```


:::

:::

## 7. Merge Multiple Datasets {#merge-multiple-datasets}

:::{.panel-tabset}

### Motivation

It is very common that you have data stored in separate files, and you need to combine them before you conduct any statistical analysis.

<br>

**Example**

If you are interested in how weather affects crop yield, you want to have weather and production data in a single dataset. However, since weather and production data are usually obtained from a different source of data (e.g., yield data from USDA-NASS, and weather data from NASS), they are stored in two separate data files.

<br>

### Basics

You can use the `merge()` function from the `data.table` package to merge two datasets.

**Basic Syntax**:
```{r}
#| eval: false
# Merge data2 to data1 keeping all rows from data1
merge(x, y, by = "key_column", all.x = TRUE)
```

+ `x`, `y`: data tables.
+ `by`, which specifies variables that let you merge two datasets.
+ `all.x = TRUE` means that all rows from `data1` are maintained in the merged dataset, and only matching rows from `data2` are included (this is equivalent to `left_join()` in `dplyr`).

Note: [The order of the datasets matter]{style="color: red;"}.


### Example

:::{.panel-tabset}

### Instructions

Let's play around with the `merge()` function using the following small data.
<!-- Let's use simple small data so that we can see whether the merge operation works correctly. -->

::: {.columns}

::: {.column width="50%"}

**Data 1**
```{webr-r}
#| autorun: true
# --- Yield data --- #
yield_data <- 
  data.table(
    state = c("Nebraska", "Iowa", "Minnesota", "Illinois", "Kansas"),
    yield = runif(n = 5, min = 180, max = 280)
  )
```
:::

::: {.column width="50%"}
**Data2**
```{webr-r}
#| autorun: true
# --- Weather data --- #
weather_data <-
  data.table(
    state = c("Iowa", "Minnesota", "Nebraska", "Illinois", "Wisconsin"),
    total_precip = runif(5, min = 10, max = 20)
  )
```
:::
:::

+ Note that states included in `yield_data` and `weather_data` are slightly different. This is to show how the `merge()` function works when there are unmatched rows in the two datasets.
+ To merge these two datasets, `state` works because we need to use `state` as a key column.
<br>


### Merge

**(1) merge `weather_data` to `yield_data`, keeping all rows from `yield_data`.**

```{webr-r}
yield_weather_data <- merge(yield_data, weather_data, by = "state", all.x = TRUE)
# check the merged data
yield_weather_data
```

<br>

**(2) merge `yield_data` to `weather_data`, keeping all rows from `weather_data`.**
```{webr-r}
weather_yield_data <- merge(weather_data, yield_data , by = "state", all.x = TRUE)
# check the merged data
weather_yield_data
```


<br>

**(3) If you want to keep all rows from both datasets, you can set `all = TRUE`.**

```{webr-r}
weather_yield_data_all <- merge(weather_data, yield_data , by = "state", all = TRUE)
# check the merged data
weather_yield_data_all
```

:::

### Quiz 1

:::{.panel-tabset}

### Quiz

(1) In the `flights` data, the `carrier` column contains two-letter codes for airlines. Let's translate these codes into the full name of the airline. 

Airline data from `nycflights13` package contains the full name of the airline corresponding to the two-letter code. The following code loads the airline data.

```{webr-r}
#| autorun: true
airlines <- nycflights13::airlines
head(airlines)
```

<br>

Merge `flights` and `airlines` data, keeping all rows from the `flights` data. Which variable should be used as a key column?

```{webr-r}
# You can write your code here
```

### Answers

+ Obviously, `flights` data is the main data, so we should keep all rows from the `flights` data.

+ The key column should be `carrier` because it is the common variable in both datasets, and it gives one-to-one correspondence between the two datasets.

```{webr-r}
flights_merged <- merge(flights, airlines, by = "carrier", all.x = TRUE)

# using dplyr, this is equivalent to
# flights_merged <- left_join(flights, airlines, by = "carrier")
```
:::

### Quiz 2

:::{.panel-tabset}

### Quiz

Run the following code to create two datasets: `yield_data` and `weather_data`.
```{webr-r}
#| autorun: true
yield_data <- 
  data.table(
    state = rep(c("Iowa", "Minnesota", "Illinois", "Kansas", "Wisconsin"), each = 2),
    year = rep(2010:2011, times = 5),
    yield = runif(n = 10, min = 180, max = 280)
  )

weather_data <- 
  data.table(
    state = rep(c("Iowa", "Minnesota", "Illinois", "Kansas", "Ohio"), each = 4),
    year = rep(2010:2013, times = 5),
    total_precip = runif(20, min = 10, max = 20)
  )
```

<br>

Merge these two datasets, keeping all rows from `yield_data`. Which variable should be used as a key column?

```{webr-r}
# you can write your code here
```

### Answers

+ Here you should use `state` and `year` as key columns. 

```{webr-r}
yield_weather_data <- merge(yield_data, weather_data, by = c("state", "year"), all.x = TRUE)
```

:::
:::




# `%>%` operator {#piping}

---

## Motivation

+ In R, you need to assign the result of each operation to a new object if you want to use the result in the subsequent process.
+ But sometimes, some objects are just intermediate results that you don't need to keep.


**Example** 

Let's create `flights_mini` data from `flights` data of `nycflights13` package in the `data.table` format. Look at the following code:

```{webr-r}
flights <- nycflights13::flights # Load flights data from nycflights13
flights_dt <- as.data.table(flights) # change the data to data.table class 
flights_mini <- flights_dt[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] # select some columns
flights_mini <- na.omit(flights_mini) # remove rows with missing values
```

The first three lines yield intermediate results to make the final `flight_mini`, and you don't need to keep those.

<br>

:::{.fragment .fade-up}
You can create `flights_mini` without using those intermediate steps with the chaining operation in `data.table` package, but [it's hard to read]{style="color:blue;"}!

```{webr-r}
flights_mini <- na.omit(data.table(nycflights13::flights)[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)])
```
:::



## Introduction


:::{.panel-tabset}

### What is `%>%`?

+ `%>%` a special symbol in R, called a pipe operator. It comes from the `magrittr` package.
+ It's a powerful tool to write linear sequence of operations in a more readable way.

<br>


::: {.callout-note}
When you load the `dplyr` package, `magrittr` package is automatically loaded as well. So, you don't need to load the `magrittr` package separately to use `%>%`.
:::


### Basics

[`%>%` takes the output of the code on its left and feeds it as the first argument to the function on its right.]{style="color: blue;"}

<br>

**Example 1**

```r
fun1(input1) 
```

is the same as 

```r
input1 %>% fun1()
```
<br>

**Example 2**

```r
output1 <- fun1(input1)
output2 <- fun2(output1)
```

is the same as 

```r
output2 <- fun1(input1) %>% fun2()
```

<br>

::: {.callout-tip}
## Shortcut for the pipe operator `%>%`
+ In RStudio, hit `Ctrl` + `Shift` + `M` (Windows) or `Cmd` + `Shift` + `M` (Mac)
:::


### More Generally

Suppose you have more than one argument for the function like this:

```r
fun(x1, x2, x3)
```

<br>


Then

```r
z %>% fun(x2, x3)
```

is equivalent to

```r
fun(z, x2, x3)
```

<br>


::: {.callout-important}
That is, by default, an R object that precedes the piping operator (`%>%`) becomes the first argument of the function that comes after the piping operator.
:::

### Refer to the Preceding Object

**What if you want to use the object defined before `%>%` as the second or third argument of the subsequent function?**

[You can refer the preceding object by `.`]{style="color: red;"} in the subsequent function. 

**Example**

```{webr-r}
# Let's use this function
print_three_words <- function(x, y, z) paste(c(x, y, z),collapse = " ")
# For example, this function prints three words with spaces between them
print_three_words(x="I", y="love", z="R")

# pass the input to the first argument
"I" %>% print_three_words(x=., y="love", z="R")

# pass the input to the second argument
"love" %>% print_three_words(x="I", y=., z="R")

# pass the input to the third argument
"R" %>% print_three_words(x="I", y="love", z=.)
```

::: {.callout-tip}
+ Whenever you use `%>%`, I recommend you always use `.` in the subsequent function to **explicitly denote the destination of the object** defined before `%>%` even if it is the first argument.
:::

:::


## Example

**Without `%>%`**
```{webr-r}
#| auto-run: true
flights <- nycflights13::flights 
flights_dt <- as.data.table(flights)
flights_mini <- flights_dt[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] 
flights_mini <- na.omit(flights_mini) 
```

**With `%>%`**
```{webr-r}
#| auto-run: true
library(dplyr)

flights_mini <- 
  nycflights13::flights %>%
  as.data.table(.) %>% 
  .[,.(year, month, origin, dest, carrier, air_time, dep_delay, arr_delay)] %>% 
  na.omit(.)
```

<br>

::: {.callout-important}
Note that the order of execution is the same as the order in which the functions are written.
:::





## Summary: {.center}

The topics in the second part of this lecture were a bit advanced. You don't need to remember the syntax of all functions we learned today. 

+ For example, I still cannot remember which function (decast() or melt()) reshapes the data from wide to long. I always need to google it.

But, I want you to know the following things at least. 

<br>

::: {.callout-important}
## Key Takeaways

1. **You can reshape data with `dcast()` and `melt()` functions.** Depending on the situation, the wide or long format may be more suitable for data analysis.

2. **You can merge data with `merge()` function.** To do so, you need to have a common key column in both datasets.
:::

You don't need to use `%>%`operator, but it would be convenient if you know how to use it. 



# Exercise Problems {#exercise-problems}

---


## Exercise 1

:::{.panel-tabset}
### Instructions

1. Find the flight company with the longest departure delay. (Hint: use `max()` function to find the maximum value of `dep_delay` column)

2. Subset the information of flights that headed to MSP (Minneapolis-St Paul International Airport) in February. Let's name it "msp_feb_flights". How many flights are there?
  

3. Calculate the median, interquartile range ($IQR = Q3 − Q1$) for `arr_delays` of flights in in the `msp_feb_flights` dataset and the number of flights, grouped by `carrier`. Which carrier has the most variable arrival delays?

<!-- https://rpubs.com/Nasif/929745 -->

::: {.callout-tip}
## Hints
IQR = Q3 − Q1 (the difference between the 75th percentile and the 25th percentile.) Use `quantile()` function to calculate the quantiles.
:::

### Answers

```{webr-r}
#| autorun: false
# === Part 1 === #
flights[dep_delay == max(dep_delay), .(carrier)]

# === Part 2 === #
msp_feb_flights <- flights[dest=="MSP" & month==2L]
nrow(msp_feb_flights)

# === Part 3 === #
msp_feb_flights[,.(
  median = median(arr_delay),
  IQR = quantile(arr_delay, 0.75) - quantile(arr_delay, 0.25),
  n_flights = .N
  ), by = carrier]
```
:::

## Exercise 2

:::{.panel-tabset}

### Instructions

If you were selecting an airport simply based on on-time departure percentage, which NYC airport would you choose to fly out of? To address this question, first, define a new variable which indicates on-time departure. On-time-departure can be defined as a departure delay of less than or equal to 0. Then, calculate the on-time departure rate for each airport.

<br>

```{webr-r}
# You can write your code here
```

### Answers

```{webr-r}
#| autorun: false
flights <- data.table(nycflights13::flights)

flights[, on_time := dep_delay <= 0] %>%
  .[, .(on_time_rate = mean(on_time, na.rm = TRUE)), by = origin]
```
:::


## Exercise 3

:::{.panel-tabset}
### Data

For this exercise problem, we will use `journal` data from the `AER` package. First, load the data and convert it to data.table object using `setDT` function (or. `as.data.table()`). Take a look at the data. Also, type `?journal` to see the description of the data.

<br>

```{webr-r}
#| autorun: false
# If you have not installed the package, run the following code
# install.packages("AER")

# load the package
library(AER)
# load the data from AER
data("Journals")

# To see the descriptions of the data, 
# type `?Journals` in the console
?Journals

setDT(Journals)
```

### Instructions

1. Calculate the average number of pages and submission delay for the entire dataset.
2. Show the `title`, `citations`, `price`, and `subs` columns for the top 5 journals (`title`) with the highest number of citations (`citations`). (Hint: use `order()` function to sort the data by `citations` in descending order.)
3. This dataset is created in the year 2000. Calculate the age (`age`) of each journal by subtracting the start year (`foundingyear`) of the journal from 2000. Select the columns, `price`, `subs`, `citations`, and `pages`, and `age`. Use that data to create a correlation matrix between those variables using the `cor()` function. (Hint: use this syntax: `cor(data)`). Can you find anything interesting from the correlation matrix?

4. `use = "complete.obs"` argument to exclude missing values from the calculation., )

```{webr-r}
# You can write your code here
```

### Solutions

```{webr-r}
#| autorun: false
# === Part 1 === #
Journals[, .(
  avg_pages = mean(pages, na.rm = TRUE),
  avg_delay = mean(submission_delay, na.rm = TRUE)
)]

# === Part 2 === #
Journals[order(-citations),] %>%
  .[, .(title, citations, price, subs)] %>%
  .[1:5]
  

\)
# === Part 3 === #
Journals[, age := 2000 - foundingyear] %>%
  .[, .(price, subs, citations, pages, age)] %>%
  cor(.)
```
:::







# Appendix {#appendix}


---

<!-- ## Appendix: Table of Contents

+ A.1. A list of useful functions
+ [A.2. Let's get used to .SD](#SD)
+ A.3. Exercise Problems 
+ A.4. Use multiple cores for computation with data.table [[Here](https://github.com/Rdatatable/data.table/wiki/Installation)] -->


## Useful functions

+ `.N`
+ `copy()`
+ `setnames()`
+ `order()`
+ `shift()`
+ `duplicated()`: find duplicates
+ `unique()`: find unique observations
+ `fcase()` is like `case_when()` in dplyr.


## fcase()

+ `fcase()` is like `case_when()` in `dplyr`. It is useful when you want to define a variable that takes different values based on conditions.

+ `fcase()` function returns the first value for which the corresponding condition is `TRUE`. If no condition is `TRUE`, it returns the default value.

```{webr-r}
x = 1:10
fcase(
	x <= 5L, 1L,
	x > 5L, 3L
)
```

<br>

**Example:** Define seasons (Winter: Dec-Feb, Spring: Mar-May, Summer: Jun-Aug, Fall: Sep-Nov)

```{webr-r}
# --- Define season --- #
flights[,season := fcase(
  month %in% c(12, 1, 2), "Winter",
  month %in% c(3, 4, 5), "Spring",
  month %in% c(6, 7, 8), "Summer",
  default = "Fall" #otherwise, "Fall`"
)]
```


<!-- ## .SD {.}

:::{.panel-tabset}

### Before starting

Let's use small `data.table` object that will help us understand what `.SD` does.

```{webr-r}
#| autorun: true

# Don't worry about this code. It just creates a small data.table object.
flights_mini <- 
  flights[,head(.SD, 2), by = month] %>% 
  .[, .(year, month, dep_delay, arr_delay)]

head(flights_mini)
```

### What is .SD?

`.SD` (which stands for Subset Data) is a special symbol that allows you to do many cool things.

Without grouping specified in `by`, `.SD` is the `data.table` itself. So, `flights_mini[, .SD]` is the same as `flights_mini`.

But, when grouped, it becomes the subset (grouped) of the data.table.


**Example:**
```{webr-r}
flights_mini[, print(.SD), by = month]
```


::: {.callout-note}
+ `.SD` contains all the columns except the grouping columns by default.
+ The original order is preserved by origin
:::

::: -->

