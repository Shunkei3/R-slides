---
title: "Day 1: Basics of R"
author: "Shunkei Kakimoto"
format: 
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    theme: 
      - default 
      - ../slide_style/styles.scss
    fontsize: 1.5em
    callout-icon: false
    scrollable: true
    echo: true
    multiplex: true
    code-link: true
    title-slide-attributes:
      data-background-color: "#447099"
    fig-dpi: 400
engine: knitr
webr:
  packages: [""]
  cell-options:
    editor-font-scale: 0.8
filters:
  - webr
---

```{css}
/*| echo: false */
/*| include: false */

figcaption {
  margin: auto;
  text-align: center;
}

.caption{
   text-align: center;
}
```

## Tips {.center}

+ Click on the three horizontally stacked lines at the bottom left corner of the slide, then you will see table of contents, and you can jump to the section you want to see.
+ Hitting letter "o" on your keyboard and you will have a panel view of all the slides.
+ You can directly write and run R codes, and see the outputs on slides. 
+ When you want to execute (run) code, hit `command` + `enter` (Mac) or `Control` + `enter` (Windows) on your keybord. Alternatively, you can click the "Run Code" button on the top left corner of the code chunk.

<br>

```{webr-r}
# This is an example of R code chunk you will see in this slide deck.
print("Let's get started!")

1 + 1
```

## 
<br>

### Goals of this lecture
+ To get familiar with the feature of RStudio.
+ To understand how to create vector, list, matrix, and data.frame in R, and how to access and modify the elements in those objects.
+ To get familiar with base R functions to do mathematical calculations.
+ To get familiar with be able to base plotting functions to visualize data.
:::

<br>


### Reference
+ [R for Data Science Ch8 Workflow: projects](https://r4ds.had.co.nz/workflow-projects.html)


### Today's outline: {.center}

1. Explore the features of Rstudio.
2. R Coding Basics
3. Basic Data Types and Data Structures
   1. Data types
   2. Data structure
4. Basic arithmetics with base function
5. Base plotting functions
6. Exercise problems
7. Appendix: Faster vector calculation for Mac user 
    + [here](https://gist.github.com/nicebread/6920c8287d7bffb03007)
    + [here](https://statistics.berkeley.edu/computing/faqs/linear-algebra-and-parallelized-linear-algebra-using-blas)



## Before you start {.center}

<br>

::: {.callout-note}
+ You don't need to memorize nor understand completely all the contents in this lecture. 
+ In the end of the each section, I set a summary of the key points you need to know. As long as you understand the key points, you are good to go.
:::


## Rstudio {.center}

These are the things you should know at least:

+ How to create R script (`.R` files)?
+ How to open files or folderz in Rstudio?
+ How to run the code line by line?
+ How to comment out the code?

<br>


::: {.callout-tip title="Rstudio tips"}
+ Run the code: [`Command` + `Enter` (Mac),  `Control` + `Enter` (Windows)]
+ Comment out the code [`Command` + `Shift` + `C` on macOS, `Ctrl` + `Shift` + `C` (Windows)]
+ Split code panes (&rarr; Pane Layout &rarr; click "Add Column")
+ inset the assignment operator (`<-`): [`Option` + `-` for Mac, `Alt` + `-`  for Windows]
:::

## 

## Before Starting: {.center}

[R programing language is object-oriented programming (OOP), which basically means: "Everything is an object and everything has a name."]{style="color: red;"}

### Generall rule in R
+ You can assign information (numbers, character, data) to an object on R using `<-` or `=` (e.g., `object_name <- value`) and resue it later.
  + If you assign contents to an object of the same name, the object that had the same name will be overwritten.
+ Once objects are created, you can evaluate them on the console to see what is inside.

```{webr-r}
# assign value 1 to an object called "x" 
x <- 1
# see what's inside object "x"
x

# assign the result of a product to an objecte called "y"
y <- 2*3

# store sum of x and y in z
z <- x + y
# see what's inside object "z"
z
# take z, add 1, and store result back in z
z <- z + 1
# Now, the value stored in z is updated.
z

# use z as an input of square root function
sqrt(z)
```
<br>

## {.center}

::: {.callout-tip title="Object naming"}
+ You can name the object whatever you want, but **it must start with a letter**. 
+ You can use `_` or `.` to in the object name.
+ It is recommended to use a meaningful name for the object so that you can understand what the object contains.
:::

<br>

```{webr-r}
# For example, this is not allowed. You will see an error.
1_test <- 1:3

# Intead, you can do this.
test_1 <- 1:3
test_1
```


## Basic data types (i.e., atomic data types) in R {.center}

::: {.panel-tabset}

### Data types in R

<br>

| Data Type  | Description                                                  | Example                           | Check Function      |
|------------|--------------------------------------------------------------|-----------------------------------|---------------------|
| numeric    | General number, can be integer or decimal.                   | `5.2`, `3L` (the `L` makes it integer) | `is.numeric()`     |
| character  | Text or string data.                                         | `"Hello, R!"`                     | `is.character()`    |
| logical    | Boolean values.                                              | `TRUE`, `FALSE`                   | `is.logical()`      |
| integer    | Whole numbers.                                               | `2L`, `100L`                      | `is.integer()`      |
| complex    | Numbers with real and imaginary parts.                       | `3 + 2i`                          | `is.complex()`      |
| raw        | Raw bytes.                                                   | `charToRaw("Hello")`              | `is.raw()`          |
| factor     | Categorical data. Can have ordered and unordered categories. | `factor(c("low", "high", "medium"))` | `is.factor()`    |


### How to check data type?
Use `class()` or `is.XXX()` to examine the data types.


```{webr-r}
class(5.2)
class(2L)
class(TRUE)

is.integer(5.2)
is.integer(2L)
```


### Data Type Conversion

You can convert one type of data to anoter type of data using `as.XXX()` function.

Three conversion functions that are used often are:
+ `as.numeric()`
+ `as.character()`
+ `as.factor()`


```{webr-r}
test_chr <- "5.2"
class(test_chr)

# convert to numeric
test_num <- as.numeric(test_chr)
test_num
class(test_num)

# convert from numeric to character type
as.character(test_num)

# conver from numeric to factor type
as.factor(test_num)
```
:::

:::{.note}
+ There six "basic types" called atomic data types for data in R:
+ You specify that some information is character data by surrounding it in either single quotes (') or double quotes ("). 
+ Factor and character are similar but different. Unlike chracter, factor is used to represent categorical data and the number of order is implictly encoded in the data.
+ 
:::

## Logical values {.center}

<!-- useful
+ Logical Indexing: https://bookdown.org/ndphillips/YaRrr/logical-indexing.html
+ Basic Data Types: https://info201.github.io/r-intro.html 
+ -->

<!-- see this:  -->
::: {.callout-important}
+ A Logical value can be either `TRUE` and `FALSE` (and these are not characters!)
+ Logical values are often results of comparison operations such as `<` (less than), `>` (greater than), `<=` (less-than-or-equal), `>=` (greater-than-or-equal), `==` (equal), and `!=` (not-equal).
+ As we will see latewr, a sequence of logical values (i.e., logical vectors) can be used index vector to subset the data!
:::

+ Relational operators (or comparison operator): `==`, `!=`, `>`, `<`, `>=`, `<=`.
+ Logical operators:  `&` (and), `|` (or), and `!` (not).

```{webr-r}
#--- true or false ---#
5 == 5
5 != 4
5 > 4
5 >= 4
5 < 4
5 <= 4

5 == 5 &  5 != 4
5 == 5 &  5 < 4
5 == 5 | 5 < 4
```


## {.center}
::: {.callout-important title="Key points"}
Know that:

+ There are multiple data types in R. 
  + Specifically, "numeric", "character", "logical" are the most common types.
+ You can check the data type using `class()` function.
+ You can convert one data type to another using `as.XXX()` function.
+ Finally, you can 
:::



## Data Structures in R {.center}

R has many data structures. These include:

<br>

| Data Structure | Description                                         | Creation Function                | Example                                               |
|----------------|-----------------------------------------------------|---------------------------------|-------------------------------------------------------|
| Vector         | Holds elements of the **same type**.                    | `c()`                           | `c(1, 2, 3, 4)`                                       |
| Matrix         | Two-dimensional; elements of the **same type**.         | `matrix()`                      | `matrix(1:4, ncol=2)`                                 |
| Array          | Multi-dimensional; elements of the **same type**.      | `array()`                       |                                                       |
| List           | Can hold elements of **different types**.               | `list()`                        | `list(name="John", age=30, scores=c(85, 90, 92))`     |
| Data Frame     | Like a table; columns can be different types.       | `data.frame()`                  | `data.frame(name=c("John", "Jane"), age=c(30, 25))`   |
                                                     |

:::{.fragment .fade-up}
::: {.callout-caution}
Here, we focus on two things:

+ How to create each of the data class.
+ How to access and modify the elements in the data.
:::
:::

:::{.notes}
+ We learned the types of element of data. Now, we are going to learn the types of data structures in R.
+ Depending on the data structure, you can store different types of data.
+ Mainly, 
:::



## Vector (one-dimensional array) {.center}

::: {.panel-tabset}

### Basics
+ A vectors is a class of object that consists of elements of the **same kind of elements** (All elements in a vector must be of the same data type). You use `c()` to create a vector.
  + As other functions to create vectore, you can use `seq()`, `rep()`.
+ You can also combine two vectors using `c()`.

```{webr-r}
# Empty vector
c()

# Create a numeric vector
x <- c(1, 2, 3) # equivalent to seq(1, 5) and 
x

# Combine another numeric vector and x
y <- c(x, c(4, 5))

# Create a character vector
z <- c("a", "b", "c")

# See what happens when you combine numeric and character vector
c(x, z)
# All the numeric values are converted to characters!
```




### Indexing
<!-- 
+ Chapter 7 Indexing Vectors with [ ]: https://bookdown.org/ndphillips/YaRrr/vectorindexing.html
+ Vector Indexing: https://thomasleeper.com/Rcourse/Tutorials/vectorindexing.html
+  -->

+ You can get a single element, or a set of specific elements of a vector by indexing with `[]` blackets. Inside `[]`, you provide anothe vector (i.e. index vector) the position of the element you want to extract 
  + e.g., `x[2]` returns the second element of `x`.

```{webr-r}
# === Positional indexing === #
# Create a numeric vector 
x <- seq(from = 1, to = 5, by = 2)
x

# Get 2nd element of x
index_vec <- 2
x[index_vec] # or simply you can do x[2]

# Get 1st and 3rd element of x
index_vec <- c(1, 3)
x[index_vec] # or simply you can do x[c(1, 3)]

# Get the last element of x without knowing the length of x.
x[length(x)]
```

You don't need to create a separate index vector.
<br>

+ If a vector has names, you can also use the name of the element to extract it.
```{webr-r}
# === Named indexing === #
# Create a numeric vector with names
y <- c(x=1, y=2, z=3)
y 

index_vec <- "x"
y[index_vec] # or simply y["x"]
```


### Logical Vectors


<!-- see the section of Corecion: https://rstudio-education.github.io/hopr/r-objects.html  -->
+ A logical vector is a vector that only contains logical values (TRUE and FALSE values).
+ You can use logical vector as an index vector to subset the data.


```{webr-r}
# Create a numeric vector 
x <- c(5, -8, 2, -1)

# === For example, let's get the positive elements === #
# create a logical vector 
y <- x > 0
# Let's see what's inside y
y

# subset the data
x[y] #Or you can simply do x[x>0]
```

<br>

The following figure shows how logical indexing works.

![Logical Indexing (cited from [here](https://bookdown.org/ndphillips/YaRrr/logical-indexing.html))](image/logical_vector.png){#fig-elephant fig-align="left" width=40%}

### Others

```{webr-r}
x <- 1:5

# Assign names to each of the elements
names(x) <- c("a", "b", "c", "d", "e")
x

# Replace a specific element to another value
x["a"] <- 100
x
```


### Exercise

The following code randomly samples 30 numbers from a uniform distribution between 0 and 1, and stores the result in `x`. 
```{webr-r}
# Run this code:
set.seed(3746)
x <- runif(n = 30, min = 0, max = 1)
```

1. Get 10th and 15th element of `x`.
2. Get elements larger than $0.5$.
3. Replace 10th and 15th element of `x` to 0.
4. If an element of `x` is larger than $0.9$, replace it with $1$.
5. Count the elements larger than $0.6$. 

```{r}
#| include: false
#| eval: false

set.seed(3746)
x <- runif(n = 30, min = 0, max = 1)

# 1.1
x[c(10,15)]
x[x > 0.5]
x[c(10,15)] <- 0
x[x > 0.9] <- 1
sum(x > 0.6)
```
:::



## Matrix

:::{.panel-tabset}

### Basics
A matrix is a class of object that consists of elements of** the same kind of elements** (All elements in a matrix must be of the same data type) stored in a** two-dimensional array**.

+ `matrix()` function is used to create a matrix.
```{webr-r}
# Create a numeric matrix
m_num <- matrix(1:6, nrow = 3)
m_num

# use dim() to see the dimension of the matrix
dim(m_num)

# Create a matrix of characters
m_chr <- matrix(c("a", "b" , "c", "d", "e", "f"), nrow = 3)
m_chr
```


You can also create a matrix by combining multiple vectors using `cbind()` or `rbind()` functions.
```{r}
vec_a <- 1:4
vec_b <- 4:7

mat1 <- cbind(vec_a, vec_b)
mat1

mat2 <- rbind(vec_a, vec_b)
mat2
```



### Indexing

In the same way as vectors, you can access the elements of a matrix using `[]` brackets. But you need to specify the row and column index.

```{webr-r}
# Create a matrix of numbers
m_num <- matrix(1:6, nrow = 3)
m_num

# Get the element in the 1st row and 2nd column
m_num[1, 2]

# Modify a specific element
m_num[1, 2] <- 100
m_num
```

### Others

```{webr-r}
# Create a matrix of numbers
m_num <- matrix(1:6, nrow = 3)

# Add column names
colnames(m_num) <- c("A", "B")
m_num
# Add row names
rownames(m_num) <- c("a", "b", "c")
m_num
```
:::

:::{.notes}
+ While vector is one-dimentional array, matrix is two-dimentional array.
+ 
:::


## data.frame

:::{.panel-tabset}

### Basics
`data.frame` is like a matrix but it can store different types of data in each column.

```{webr-r}
# create a data.frame 
yield_data <- 
  data.frame(
    Nitrogen = c(200, 180, 300),
    Yield = c(240, 220, 230),
    State = c("Kansas", "Nebraska", "Iowas")
  )
yield_data
```


There are different kinds of objects that are like "data.frame":

+ `tibble`
+ `data.table`

We will learn these in the next lecture!


### Indexing

You can access the elements of a data.frame using `[]` brackets. But you need to specify the row and column index.

```{webr-r}
yield_data <- 
  data.frame(
    Nitrogen = c(200, 180, 300),
    Yield = c(240, 220, 230),
    State = c("Kansas", "Nebraska", "Iowas")
  )
yield_data

# Get the elements in the 1st row 
yield_data[1, ]

# Get the elements in the 1st column
yield_data[ , 1]

# Get the element in the 1st row and 2nd column
yield_data[1, 2]

# Or you can use the column name
yield_data[1, "Yield"]

# Find a state whose yield is more than 225
yield_data[yield_data$Yield > 225, ]
```

### Others

```{webr-r}
yield_data <- 
  data.frame(
    Nitrogen = c(200, 180, 300),
    Yield = c(240, 220, 230),
    State = c("Kansas", "Nebraska", "Iowas")
  )

# column names
names(yield_data) #or colnames(yield_data)

# Change the column names to lower case
names(yield_data) <- tolower(names(yield_data))
yield_data
```
:::


## List

+ A `list` is a class of object that consists of elements of mixed types. You can create a list using `list()` function.

```{webr-r}
list_a <- list(1, 2, "3", 4)
list_a
```


A list is very flexible. It can hold basically any type of R objects as its elements.

```{webr-r}
# Create a numeric vector 
vec_a <- 1:4
# Create a 
# Create a data.frame
yield_data <- 
  data.frame(
    Nitrogen = c(200, 180, 300),
    Yield = c(240, 220, 230),
    State = c("Kansas", "Nebraska", "Iowas")
  )



```

## Summary {.center}

Don't worry about the details. You'll get used to these data structures as you use R more. Here are the key points you need to knowb at this point:

::: {.callout-important title="key points"}
+ To know that how to create vector, matrix, data.frame, and list object in R.
  + Among all, `data.frame` is the most common data structure you will see when you work with the real-world data. 
  + (In the next lecture, we will learn advanced data structures such as `tibble` and `data.table`.)
+ To know that how to access elements of an object (Use indexing with `[]`).
  + positional indexing, named indexing, and logical indexing.
:::

<br>

::: {.callout-tip}
Use `class()` function to know the class of data structure you're working on.
:::


## Exercise Problems

<!-- create a problem related to vector and data.frame -->


# Matrix/Linear Algebra in R

---

:::{.panel-tabset}
### Basic arithmetics
```{webr-r} 
#--- addition ---#
2 + 3
#--- subtraction ---#
6 - 2
#--- multiplications ---#
6 * 2
#--- exponentiation ---#
2 ^ 3
#--- division ---#
6 / 2
#--- remainder ---#
9 %% 4
#--- quotient ---#
9 %/% 4
```


### Vector calculation

```{r}
a <- c(1, 3, 2)
b <- c(5, 7, 6)

# --- Addition --- #
a + 1
a + b

# --- Substraction --- #
a - 1
b - a

# --- Multiplication --- #
a*2
a*b
```


### Matrix calculation

+ As you saw in the vector calculation, R can calculate element-wise operations. If you want to do matrix multiplication, you need to use `%*%` operator.

```{webr-r}
mat_a <- matrix(1:4, nrow = 2)
mat_b <- matrix(4:7, nrow = 2)


#--- Matrix Addition and Substraction ---#
mat_a + mat_b
mat_b - mat_a

# --- Matrix Multiplication using %*% operator --- #
mat_a %*% mat_b

# --- Matrix Transpose --- #
t(mat_a)
```
:::




# Loading and Saving Data


---

## R base functions for data import and export


+ Like other softwares (e.g., Stata, Excel) do, R has two native data formats: `.Rdata` (or `.rdata`) and `.Rds` (or `.rds`) 
  + `.Rdata` is used to save multiple R objects, 
  + `.Rds` is used to save a single R object


<br>

:::: {.columns}
::: {.column width="50%"}
**.Rdata** format

+ Load data: 

```load("path_to_Rdata_file")```

+ Save data: 

```save(object_name, file = "path_to_Rdata_file")```
:::


::: {.column width="50%"}
**.Rds** format

+ Load data: 

```readRDS("path_to_Rds_file")```

+ Save data: 
  
```saveRDS(object_name, file = "path_to_Rds_file")```
:::
::::



:::{.notes}
+ An rds ( r data set) file is a file type that is supported by R.
:::



## Setting the working directory

:::{.panel-tabset}

### Motivation

[To access to the data file, you need to provide the path to the file (the location of the data file).]{style="color:red;"}

<br>

**Example** 

Suppose that I want to load `flight.rds` in the Data foler. On my local computure, the full path (i.e., aboslute path) to the file is `/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data/flight.rds`.

```{r}
#| eval: false
# this code only works in my local machine
flight_dt <- readRDS(file = "/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data/flight.rds")
```

<br>

::: {.callout-caution}
## Problems
1. I do not want to provide the full path every time I load the data. It's too cumbersome.
2. If you are working with a team, the path to the data file is different for each person.
:::



### Working Directory

+ **Working Directory** is a file path on your computer where R looks for files that you ask it to load, and where it will put any files that you ask it to save.
  + You can check the current working directory using `getwd()` function.
  + By default, R (`.R` file) uses your home directory as the working directory.

```{r}
#| eval: false
# On your Rsdutio, run the following code
getwd() #wd stands for working directory
# In my case, this returns my home directory: "/Users/shunkeikakimoto"
```


### setwd()
+ If you expect to import and/or export (save) datasets and R objects often in that particular directory, it would be nice to tell R to look for files in the directory by default.
+ You can use `setwd()` to designate a directory as the working directory:

**Example 1**

In my case, I set the working directory to the `Data` folder. 

```{r}
#| eval: false
setwd("/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data")
```

Now, R will look for the data file in the `Data` folder by default. So, I can load the data using *relative path*, not *absolute path*.

```{r}
#| eval: false
flight_dt <- readRDS(file = "flight.rds")
```

<br>

:::{.fragment .fade-up}
::: {.callout-caution}
## Problems
+ Still, `setwd()` relies on an absolute file path, which might vary by person (e.g., some persom save folder in Dropbox, other person uses Google Drive). 
+ So, designating working directory using `setwd()` does not solve the second problme completely (i.e, If you are working with a team, the path to the data file is different for each person.)
:::
:::


### R project

:::{.panel-tabset}

### What is it?

> "R experts keep all the files associated with a project together — input data, R scripts, analytical results, figures. This is such a wise and common practice that RStudio has built-in support for this via **projects**." - [R for Data Science Ch 8.4](https://r4ds.had.co.nz/workflow-projects.html?q=working%20directory#rstudio-projects)

<br>

::: {.callout-caution}
## RStudio Projects

+ An RStudio project is a way to organize your work.

+ Once R project is loaded, it automatically sets current working directory to the folder where that `.Rproj` file is saved (you don't need `setwd()`!).

+ As long as the folder structure in the project folder is the same (relative path from the folder containing `.Rproj` file), you can share the code involving data loading with your team members.
:::



### Let's create a project!

Follow this steps illustrated in this document: [R for Data Science Ch 8.4](https://r4ds.had.co.nz/workflow-projects.html?q=working%20directory#rstudio-projects)

### Load the data

+ On your Rstudio, check the top-right corner of the Rstudio window. You will see the name of the project you created.
  + Alternatively, you can open the project by clicking the `.Rproj` file via Finder (Mac) or File Explorer (Windows).

+ Now, let's check the current working directory using `getwd()` function. You will see the path to the project folder.
+ Let's load `flight.rds` data file with `readRDS()` function.
:::

:::


## Loading the data

+ R can load data from various formats including `.csv`, `.xls(x)`, and`.dta`.
+ There exists many functions that can help you to load data:
  + `read.csv()` to read a `.csv` file
  +  `read_excel()` from the `readxl` package to read data sheets from an `.xls(x)` file
  + `read.dta13()` function from the `readstata13` package to read a STATA data file (`.dta`)

<br>

:::{.fragment .fade-up}
::: {.callout-important}
## Use import() function
+ **But** `import()` function from the `rio` package might be the most coveneint one to load various format of data. 
  + Unlike, `read.csv()` and `read.dta13()` which specialize in reading a specific type of file, `import()` can load data from various sources.
:::
:::

<br>


:::{.fragment .fade-up}
**Let's do it:**

In `Data` folder, `flight` data is saved with three different formats: `flight.csv`, `flight.dta`, and `flight.xlsx`. Let's load the data using `import()` function on your Rstudio.

```{webr-r}
# If you don't have the rio package, install it by running the following code:
# install.packages("rio")
library(rio)
```
:::


## Saving the data

+ You can save the data with varioius format.
+ **But**, Unless necessary, it is recommended to save the data in `.rds` format.
  + how?: `saveRDS(object_name, path_to_save)`

<br>

**Reasons**
+ If you work with R, there is no reason to save the data in other format than `.rds`.
+ `.rds` format is more efficient in terms of saving and loading the data.
  + Check the size of the `flight` data files in different formats. Which one is the smallest?

<br>

Let's try!

+ Load the `flight` data in the `Data` folder.
+ Subset 

```{webr-r}
flights <- readRDS("Data/flight.rds")
```



## Summary

Here are the key points you need to know:

**Very Important**
+ how to create `vector`, `matrix`, `data.frame`, and `list` objects in R.
+ how to access and modify the elements in the data.
+ how indices work in R (positional, named, and logical indexing), and understand that you can use them to subset the data.
  + This is the basic mechanism how R subset rows.
+ How to load and save the data in R.

<br>

**Important**
+ how to select columns and create a new column in the data.frame.
  + `with` and `within` function



In the next lecture, we will learn about data manipulation using `data.table` package.


# Exercise Problems
<!-- create a problem related to vector and data.frame -->


## Exercise Problems 1: Vector

:::{.panel-tabset}

### Problems

<!-- From this [webwise](https://www.w3resource.com/r-programming-exercises/) -->

1. Create a sequence of numbers from 20 to 50 and name it `x`. Let's change the numbers that are multiples of 3 to 0.

2. `sample()` is commonly used in Monte Carlo simulation in econometrics. Run the following code to create `r`. What does it do? Use `?sample` to find out what the function does.

```{webr-r}
#| autorun: true
setwd(12345) #don't worry about this
r <- sample(1:100, size=20, replace = TRUE)
```

3. Find the value of mean and SD of vector `r` without using `mean()` and `sd()`
4. Figure out which position contains the maximum value of vector `r`. (use `which()` function. Run `?which()` to find out what the function does.)
5. Exctract the values of `r` that are larger than 50.
6. Exctract the values of `r` that are larger than 40 and smaller than 60.
7. Exctract the values of `r` that are smaller than 20 or larger than 70.


### Answers

```{webr-r}
# === Part 1 === #
x <- 20:50
# using `:` operator is the most basic way to create a sequence of numbers, but it only works with integer numbers with a step of 1.
# seq() function is more flexible. For example, you can create a sequence of numbers, , incremented by 0.5.
# x <- seq(from = 20, to = 50, by = 0.5)
x[x %% 3 == 0] <- 0

# === Part 2 === #
# In this code, sample() function creates a random sample of numbers with size 20 (size=20) from a range 1 to 100 (x = 1:100) allowing replacement (replace = TRUE).

# === Part 3 === #
# mean
mean_r <- sum(r) / length(r)
# SD
sd_r <- sqrt(sum((r - mean_r)^2) / (length(r) - 1))

# === Part 4 === #
max_index <- which(r == max(r))

# === Part 5 === #
r_50 <- r[r > 50]

# === Part 6 === #
r_40_60 <- r[r > 40 & r < 60]

# === Part 7 === #
r_20_70 <- r[r < 20 | r > 70]
```
:::


## Exercise Problem 2: Data Frame
  

:::{.panel-tabset}

### Problem 

<!-- I adapted the following problem from the in-class exercise of the course Programming for Econometrics (APEC 8221). -->

<br>

1. Load the file `nscg17small.dta`. You can find the data in the `Data` folder. 
   + This data is a subset of the National Survey of College Graduates (NSCG) 2017, which collects data on the educational and occupational characteristics of college graduates in the United States.

2. Each row corresponds to a unique respondent. Let's create a new column called "ID". There are various ways to create an ID column. Here, let's create an ID column that starts from 1 and increments by 1 for each row.
3. Get the descriptive statistics of the salary (use `summary()` function).
4. Create a new variable in your data that represents the z-score
of the hours worked (use `hrswk` variable).
$$Z = (x - \mu)/\sigma$$
, where $Z = \text{standard score}$, $x =\text{observed value}$, $\mu = \text{mean of sample}$, and $\sigma = \text{standard deviation of the sample}$.
1. Calculate the share of observations in your data sample with
above average hours worked.


### Answer

```{webr-r}
# === Part 1 === #
nscg17 <- rio::import("Data/nscg17small.dta")

# === Part 2 === #
nscg17$ID <- 1:nrow(nscg17)

# === Part 3 === #
summary(nscg17$salary)

# === Part 4 === #
nscg17$z_hrswk <- (nscg17$hrswk - mean(nscg17$hrswk)) / sd(nscg17$hrswk)
# or using with() function, you can write the code more concisely
# nscg17$z_hrswk2 <- with(nscg17, (hrswk - mean(hrswk)) / sd(hrswk))

# Note: For part 2 and 3, you can use within() function to create new columns more concisely.
# nscg17 <- 
#   within(
#     nscg17, {
#       ID <- 1:nrow(nscg17)
#       z_hrswk <- (hrswk - mean(hrswk)) / sd(hrswk)
#     }

# === Part 5 === #
# create a logical vector that indicates whether the hours worked is above average
above_avg_hrswk <- with(nscg17, z_hrswk > mean(z_hrswk)) # you can get the same result by using `hrswk`.
# subset the data
nscg17_above_avg_hrswk <- nscg17[above_avg_hrswk, ]
# calculate the share of observations with above average hours worked
share_above_avg_hrswk <- nrow(nscg17_above_avg_hrswk) / nrow(nscg17)
share_above_avg_hrswk
```
:::

## Exercise Problems 3 (Adcanced)
:::{.panel-tabset}

### Problem

Let's use `flight.rds` data in the `Data` folder. Load the data. We will only look at the flights data with "MSP" (Minneapolis–Saint Paul International Airport) as the destination airport. 

[For each airline company (`carrier`), find the proportion of flights that are delayed more than 30 minutes.]{style="color: blue;"}

<br>

::: {.callout-note}
+ You can solve this exercise problme by using only base-R functions. See Hints if you need help.
+ Also, note that googling is one of the most important skills for coding!
:::


### Hints (step by step)

Here are the steps that I took to solve the problem. You do not neccearily need to follow the steps.

1. Load the `flight.rds` data in the `Data` folder.
2. Select the columns `year`, `month`, `day`, `dep_delay`, `arr_delay`, `dest`, and  `carrier`, and subset rows that have "MSP" as `dest`. Let's name the data `flights_mn`.
3. In `flights_mn`, create a new column called `total_delay` which is the sum of `dep_delay` and `arr_delay`. Further, create a new column called `delay_type` which takes character `"delay_more_30"` if `total_delay` is more than 30 minutes, and character `"others"` (or 0) otherwise.
   + You can use `ifelse()` function to create a bianary variable, `delay_type`.

4. Count the binary categoy `delay_type` by `carrier`. Let's name the result `flights_mn_delay_count`.
   + `table()` is an R base function to create frequency table. For example, `table(data$x)` creates a frequecncy table of `x` in the data. `table(data$x, data$y)` creates a frequency table of each combination of `x` and `y` in the data.
   + After you create the table, translate the `table` to `data.frame` class using `as.data.frame.matrix()` function to make it easier to manipulate.
5. Finally, in `flights_mn_delay_count`, derive the proportion of flights that are delayed more than 30 minutes for each airline company.


### Answers

There are multiple ways to solve the problem. Here is one of the possible solutions.

```{webr-r}
#| eval: false
# === Step 1: Load data === #
# flights <- readRDS("Data/flight.rds")
# the data is created with the following code:
flights <- nycflights13::flights
flights <-  na.omit(flights)
flights <-  as.data.frame(flights)

# === Part 2: subset data === #
# define the columns to select
select_cols <- c("year", "month", "day", "dep_delay", "arr_delay", "dest", "carrier")
flights_mn <- flights[flights$dest == "MSP", select_cols]

# === Part 3: Create total_delay and delay_type === #
# the most basic approach is 
flights_mn$total_delay <- flights_mn$dep_delay + flights_mn$arr_delay
flights_mn$delay_type <- 
  ifelse(flights_mn$total_delay>30, "delay_more_30", "others")

# alternatively, you can use within() function like this:
flights_mn <- within(
  flights_mn, {
    total_delay <- dep_delay + arr_delay
    delay_type <- ifelse(flights_mn$total_delay>30, "delay_more_30", "others")
  }
)

# === Part 4: count === #
flights_mn_delay_count <- table(flights_mn$carrier, flights_mn$delay_type)
# same as
flights_mn_delay_count <- with(flights_mn, table(carrier, delay_type))
# translate the table to data.frame class to make it easier to manipulate
flights_mn_delay_count <- as.data.frame.matrix(flights_mn_delay_count)


# === Part 5: derive proportion of flights delayed more than 30 mins === #
# I will only show the code using within() function
flights_mn_delay_count <- within(
  flights_mn_delay_count,
  {
    total_flights <- others + delay_more_30
    prop_more_30 <- delay_more_30 / total_flights
  }
)
flights_mn_delay_count
```
:::


## A List of Useful R Built-in Functions

### For data manipulation


| Function                  | Description                                                                     |
|---------------------------|---------------------------------------------------------------------------------|
| `length()`                | get the length of the object                                                    |
| `nrow()`,` ncol()`        | get the number of rows or columns                                               |
| `dim()`                   | get the dimension of the data                                                   |
| `rbind()`,` cbind()`      | Combine R Objects by rows or columns                                            |
| `colMeans()`, `rowMeans()`| calculate the mean of each column or row                                        |
| `with` and `within()`     | You don't need to use `$` every time you access to the column of the data.frame.|
| `ifelse()`                | create a binary variable                                                        |
| `paste()`, `paste0()`     | concatenate strings                                                             |

<br>

### For numerical manipulation
| Function                                   | Description                                           |
|--------------------------------------------|-------------------------------------------------------|
| `sum(), mean(), var(), sd(), max(), min()` |                                                       |
| `log()` and `exp()`                        | Logarithms and Exponentials                           |
| `sqrt()`                                   | Computes the square root of the specified float value.|
| `sample()`                                 | randomly sample from a vector                         |
| `rnorm()`                                  | generate random numbers from normal distribution      |
| `runif()`                                  | generate random numbers from uniformal distribution   |


## For mac user: Accelerating R


+ By default, R uses two libraries for performing common mathematical operations: Basic Linear Algebra Subprograms (BLAS) and LAPACK (Linear Algebra Package). For mac user, instead of the BLAS library that comes with R, you can use Apple's vecLib (libBLAS.dylib), which is optimized for Apple to perform computations on large vectors.
+ I have did this on my local machine. I am not sure if this works on your machine (especially for Windows). But you can try it if you're interested in speeding up R.


See this articles:
+ Faster matrix math in R on macOS [here](https://mpopov.com/blog/2019/06/04/faster-matrix-math-in-r-on-macos/)
+ Accelerating R [here](https://higgicd.github.io/posts/accelerating_r/)
+ Even faster matrix math in R on macOS with M1 [here](https://mpopov.com/blog/2021/10/10/even-faster-matrix-math-in-r-on-macos-with-m1/)


<br>

On my local machine (Mac Studio, Apple M2 Ultra), I did some benchmarking. Here is the result:

:::{.panel-tabset}


### Benchmarking 1

Large matrix computation: 

```{r}
#| eval: false
library(microbenchmark)
d <- 1e3
x <- matrix(rnorm(d^2), d, d)
microbenchmark(tcrossprod(x), solve(x), svd(x), times = 10L)
```

With R's defalt vecLic
```
Unit: milliseconds
          expr       min        lq      mean    median        uq       max neval cld
 tcrossprod(x)  162.7597  163.4417  164.8034  164.3118  165.0813  170.2188    10 a  
      solve(x)  499.0541  504.7357  508.1698  508.7415  512.4554  514.0756    10  b 
        svd(x) 2133.5679 2142.4570 2154.6426 2150.8079 2156.8922 2212.0459    10   c
```

<br>

With Apple's vecLib (libBLAS.dylib)
```
Unit: milliseconds
          expr        min         lq       mean     median         uq        max neval cld
 tcrossprod(x)   1.765378   1.838358   2.313618   2.182123   2.669059   3.525303    10 a  
      solve(x)  17.034680  17.186995  19.042413  18.740895  20.487454  22.760617    10  b 
        svd(x) 138.515056 140.338654 146.949088 141.768673 145.612115 190.427042    10   c
```


### Benchmarking 2

Regression on large data: 

**Code**
```{r}
#| eval: false
library(microbenchmark)
set.seed(20190604)
n <- 1e3
p <- 1e2
b <- rnorm(p + 1, 0, 10)
x <- matrix(runif(n * p, -10, 10), ncol = p, nrow = n)
y <- cbind(1, x) %*% b + rnorm(n, 0, 2)
microbenchmark(lm(y ~ x))
```

With R's defalt, 
```
Unit: milliseconds
      expr      min       lq     mean   median       uq      max neval
 lm(y ~ x) 7.699226 8.078886 8.494211 8.331692 8.541182 10.65077   100
```

<br>

With Apple's vecLib (libBLAS.dylib)
```
Unit: milliseconds
      expr      min       lq     mean   median       uq      max neval
 lm(y ~ x) 4.459447 4.578736 4.875943 4.656206 4.732282 10.26915   100
```
:::