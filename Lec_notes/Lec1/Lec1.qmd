---
title: "Day 1: Basics of R"
subtitle: "Department of Applied Economics, University of Minnesota"
author: "Shunkei Kakimoto"
format: 
  revealjs:
    self-contained: false
    slide-number: c/t
    width: 1600
    height: 900
    theme: 
      - default 
      - ../slide_style/styles.scss
    fontsize: 1.5em
    callout-icon: false
    scrollable: true
    echo: true
    cache: true
    warning: false
    multiplex: true
    code-link: true
    title-slide-attributes:
      data-background-color: "#447099"
    fig-dpi: 400
    chalkboard: true
    preview-links: true
webr:
  packages: [""]
  cell-options:
    editor-font-scale: 0.8
filters:
  - webr
---

```{css}
/*| echo: false */
/*| include: false */

figcaption {
  margin: auto;
  text-align: center;
}

.caption{
   text-align: center;
}
```

## {.center}

### Slide Guides

+ Click on the three horizontally stacked lines at the bottom left corner of the slide, then you will see table of contents, and you can jump to the section you want to see.
+ Hitting letter "o" on your keyboard and you will have a panel view of all the slides.
+ You can directly write and run R codes, and see the outputs on slides. 
+ When you want to execute (run) code, hit `command` + `enter` (Mac) or `Control` + `enter` (Windows) on your keyboard. Alternatively, you can click the "Run Code" button on the top left corner of the code chunk.

<br>

```{webr-r}
# This is an example of R code chunk you will see in this slide deck.
print("Let's get started!")

1 + 1
```

## {.center}

Today's lecture is very basic concept of R programming. So, it might be boring for those who are already familiar with R. But, please be patient. This will be helpful if you use advanced functions in the future.

Instead of leaving the R process as a black box, it's better to have some knowledge about what's happening inside the R process! 


## {.center}
<br>

### **Learning Objectives**
+ To understand the R coding rules.  
+ To understand the basic types of data and structure in R, and to be able to manipulate them.
+ To be able to use base R functions to do some mathematical calculations.
+ To be able to create R project, and to be able to save and load data in R.
:::

<br>

### **Reference**
+ [Section 6: Workflow: scripts, R for Data Science](https://r4ds.had.co.nz/workflow-scripts.html){target="_blank"}
+ [Section 8: Workflow: projects, R for Data Science](https://r4ds.had.co.nz/workflow-projects.html){target="_blank"}


## {.center}

### Today 's outline

1. R Coding Basics
2. Basic Data Types and Data Structures
   1. Data types
   2. Data structure
3. Basic arithmetics with base function
4. Base plotting functions
5. Exercise problems
6. Appendix: Faster vector calculation for Mac user 
    + [here](https://gist.github.com/nicebread/6920c8287d7bffb03007)
    + [here](https://statistics.berkeley.edu/computing/faqs/linear-algebra-and-parallelized-linear-algebra-using-blas)



## Before you start {.center}      

<br>

::: {.callout-note}
+ You don't need to memorize nor completely understand all the contents in this lecture. 
+ In the end of the each section, I set a summary of the key points you need to know. As long as you understand those key points, you are good to go.
:::


## General coding rule in R

::: {.panel-tabset}

### Basics
::: {.callout-important}
+ R programming language is object-oriented programming (OOP), which basically means: "Everything is an object and everything has a name."

+ You can assign information (numbers, character, data) to an object with `<-` or `=` (e.g., `object_name <- value`) and reuse it later.
  + e.g `x <- 1` assigns 1 to an object called `x`.
+ If you assign information to an object of the same name you already used, the object that had the same name will be overwritten.
+ Once objects are created, you can evaluate them to see what's inside.
:::

<br>

**Example**

```{webr-r}
# assign value 1 to an object called "x" 
x <- 1
# see what's inside object "x"
x

# assign the result of a product to an object called "y"
y <- 2 * 3

# store sum of x and y in z
z <- x + y
# see what's inside object "z"
z
# take z, add 1, and store result back in z
z <- z + 1
# Now, the value stored in z is updated.
z

# calculate the square of z
z^2
```


### Object Naming

::: {.callout-important}
+ You can name the object whatever you want, but **it must start with a [letter]{style="color:red;"}**. 
+ You can use `_` or `.` to in the object name.
+ It is recommended to use a meaningful name for the object so that you can understand what the object contains.

:::
<br>

```{webr-r}
# For example, this is not allowed. You will see an error.
1_test <- "R is fun"

# Instead, you can do this.
test_1 <- "R is fun"
test_1
```

### Packages

::: {.callout-important}

R has a lot of packages that provide additional functions and data. To use the functions in the package:

+ You need to install the package with `install.packages("package_name")`. (You need to do this only once.)

+ Whenever you want to use the functions in the package in the current R session, you need to load the package with `library(package_name)`.
:::

<br>

+ You'll get an error message like `could not find function "xxxx"` if you forget to load the package.


:::


## Basic data types (i.e., atomic data types) in R

::: {.panel-tabset}

### Data types in R
These are the basic data elements in R. 

<br>

| Data Type  | Description                                                  | Example                           | 
|------------|--------------------------------------------------------------|-----------------------------------|
| **numeric**    | General number, can be integer or decimal.                   | `5.2`, `3L` (the `L` makes it integer) |
| **character**  | Text or string data.                                         | `"Hello, R!"`                     |
| **logical**    | Boolean values.                                              | `TRUE`, `FALSE`                   |
| integer    | Whole numbers.                                               | `2L`, `100L`                      |
| complex    | Numbers with real and imaginary parts.                       | `3 + 2i`                          |
| raw        | Raw bytes.                                                   | `charToRaw("Hello")`              |
| factor     | Categorical data. Can have ordered and unordered categories. | `factor(c("low", "high", "medium"))`|

<br>

::: {.callout-note}
+ Don't worry about the details. **numeric** , **character**, and **logical** are the most common data types you will see in R.
+ [If you uses character type, you alway need to put the text in either single quotes (') or double quotes (").]{style="color:red;"}
:::


### How to check data type?
Use `class()` or `is.XXX()` to examine the data types.


```{webr-r}
class(5.2)
class(2L)
class(TRUE)
```


### Data Type Conversion

You can convert one type of data to another type of data using `as.XXX()` function.

Three conversion functions that are used often are:

+ `as.numeric()`
+ `as.character()`
+ `as.factor()`


```{webr-r}
test_chr <- "5.2"
class(test_chr)

# convert to numeric
test_num <- as.numeric(test_chr)
test_num
class(test_num)

# convert from numeric to character type
as.character(test_num)

# convert from numeric to factor type
as.factor(test_num)
```
:::

:::{.notes}
+ There six "basic types" called atomic data types for data in R:
+ You specify that some information is character data by surrounding it in either single quotes (') or double quotes ("). 
+ Factor and character are similar but different. Unlike character, factor is used to represent categorical data and the number of order is implicitly encoded in the data.
:::

## Logical values (a.k.a. Boolean values) (important)

<!-- start panel:logical   --> 
:::{.panel-tabset} 
### Basics

<!-- see this:  -->
::: {.callout-important}
+ A Logical values are `TRUE`, `FALSE`, and `NA` (not available, undefined value).
+ Logical values are often results of comparison operations such as `<` (less than), `>` (greater than), `<=` (less-than-or-equal), `>=` (greater-than-or-equal), `==` (equal), and `!=` (not-equal).
+ As we will see later, [a sequence of logical values (i.e., logical vectors) can be used index vector to subset the data.]{style="color:red;"}
+ When logical value is used like numeric, `TRUE` is treated as 1 and `FALSE` is treated as 0.
:::

+ Relational operators (or comparison operator): `==`, `!=`, `>`, `<`, `>=`, `<=`.
+ Logical operators:  `&` (and), `|` (or), and `!` (not).


:::{.notes}
+ Every relation can be evaluated as either `TRUE` or `FALSE`, or `NA`

:::

### Example

```{webr-r}
#--- true or false ---#
5 == 5
5 != 4
5 > 4
5 >= 4
5 < 4
5 <= 4

5 == 5 &  5 != 4
5 == 5 &  5 < 4
5 == 5 | 5 < 4

TRUE + TRUE
TRUE + FALSE
```
<!-- end panel:logical  --> 
:::

<!-- useful
+ Logical Indexing: https://bookdown.org/ndphillips/YaRrr/logical-indexing.html
+ Basic Data Types: https://info201.github.io/r-intro.html 
+ -->


## {.center}
::: {.callout-important title="Key points"}

At this point, 

+ There are specific definition of data types in R. 
  + Specifically, "numeric", "character", "logical" are popular.
+ You can check the data type using `class()` function.
+ You can convert one data type to another using `as.XXX()` function.
+ Remember that logical values can play some important roles in R. 
:::


## Data Structures in R {.center}

If data are combined in a specific way, it is has a specific form of structure. 

<br>

| Data Structure | Description                                         | Creation Function                | Example                                               |
|----------------|-----------------------------------------------------|---------------------------------|-------------------------------------------------------|
| Vector         | One-dimentional; Holds elements of the **same type**.                    | `c()`                           | `c(1, 2, 3, 4)`                                       |
| Matrix         | Two-dimensional; Holds elements of the **same type**.         | `matrix()`                      | `matrix(1:4, ncol=2)`                                 |
| Array          | Multi-dimensional; Holds elements of the **same type**.      | `array()`                       |    `array(c(1:12), dim = c(2, 3, 2))`                  |
| List           | Can hold elements of **different types**.               | `list()`                        | `list(name="John", age=30, scores=c(85, 90, 92))`     |
| Data Frame     | Like a table; Each column can hold different data types. This is the common data structure.       | `data.frame()`                  | `data.frame(name=c("John", "Jane"), age=c(30, 25))`   |
                                                     |

<br>

:::{.fragment .fade-up}
::: {.callout-note}
Here, we focus on how to create and how to each of the data structure.
:::
:::

:::{.notes}
+ We learned the types of element of data. Now, we are going to learn the types of data structures in R.
+ Depending on the data structure, you can store different types of data.
+ Mainly, 
:::

## Vector (one-dimensional array)

::: {.panel-tabset}

### Basics
+ A vectors object is a collection of data that are all the same type.
+ It's a sequence of numbers, characters, or logical values.
+ You use `c()` to create a vector. ("c" means "combine" or "concatenate"), You can also combine two vectors using `c()`.

<br>

**Basic syntax**

```r
c(element1, element2, element3, ...)
```

<br>

You can name each element in a vector:

```r
c(x1 = element1, x2 = element2, x3 = element3, ...)
```


### Example

```{webr-r}
# Empty vector
c()

# Create a numeric vector
x <- c(1, 2, 3)
x

# Combine another numeric vector and x
y <- c(x, c(4, 5))

# Create a character vector
z <- c("a", "b", "c")

# See what happens when you combine numeric and character vector
c(x, z) #numeric is always coerced to character (power relationship, character > numeric > logical, not important)
```

:::


## Vector: How to Manipulate?

<!-- start panel:Vector 2   --> 
:::{.panel-tabset} 
### Indexing 

**Basics**

<!-- 
+ Chapter 7 Indexing Vectors with [ ]: https://bookdown.org/ndphillips/YaRrr/vectorindexing.html
+ Vector Indexing: https://thomasleeper.com/Rcourse/Tutorials/vectorindexing.html
+  -->
+ You can retrieve a single or a multiple elements of a vector by indexing with `[]` brackets. Inside `[]`, you simply provide another vector containing the position of the element you want to extract.

+ If a vector has names, you can also use the name of the element to extract it.

+ To modify a specific element, you can assign a new value to the position you want to modify.
<br>


**Example**

```{webr-r}
# --- Create a numeric vector --- #
x <- c(x1 = 5, x2 = -8, x3 = 2, x4 = -1)

# --- Get the 1nd and 2nd element of x --- #
index_vec <- c(1, 2)
x[index_vec] #or simply you can do x[c(2, 3)]

# --- Get x1 and x2 --- #
index_vec <- c("x1", "x2")
x[index_vec] #or simply you can do x[c("x1", "x2")]

# --- Modify --- #
x[c(1, 2)] <- c(100, 200)
x
```


### Logical Vectors

<!-- see the section of Corecion: https://rstudio-education.github.io/hopr/r-objects.html  -->

+ A logical vector is a vector that only contains logical values (TRUE and FALSE values).
+ [You can use logical vector as an index vector to subset elements of the vector. Only the elements that correspond to TRUE values are returned]{style="color:red;"}.

**Example**

```{webr-r}
# --- Create a numeric vector --- #
x <- c(5, -8, 2, -1)

# === For example, let's get the positive elements === #
# create a logical vector (condition)
y <- x > 0
# Let's see what's inside y
y

# subset the data
x[y] #Or you can simply do x[x>0]
```

The following figure explains the mechanism of logical indexing.

![Logical Indexing (cited from [here](https://bookdown.org/ndphillips/YaRrr/logical-indexing.html))](image/logical_vector.png){fig-align="center" width=30%}

<!-- ### Miscellaneous

`names()` function is a useful function to assign or extract names of each element of a vector.

+ You can use this function to assign/extract column names of `data.frame` class object (`tibble` and `data.table`).


```{webr-r}
x <- 1:5

# Assign names to each of the elements
names(x) <- c("a", "b", "c", "d", "e")
x

# Extract the names
names(x)
``` -->

 
<!-- end panel:Vector 2  --> 
:::



## Exercise


The following code randomly samples 30 numbers from a uniform distribution between 0 and 1, and stores the result in `x`. 

```{webr-r}
# Run this code to work on the exercise problems.
set.seed(3746)
x <- runif(n = 30, min = 0, max = 1)
x # see what's inside x
```

**Questions**

1. Get 10th and 15th element of `x`.
2. Get elements larger than $0.5$.
3. Replace 10th and 15th element of `x` to 0.
4. If an element of `x` is larger than $0.9$, replace it with $1$.
5. Count the elements larger than $0.6$. 

```{r}
#| include: false
#| eval: false

set.seed(3746)
x <- runif(n = 30, min = 0, max = 1)

# 1.1
x[c(10,15)]
x[x > 0.5]
x[c(10,15)] <- 0
x[x > 0.9] <- 1
sum(x > 0.6)
```


## Matrix (Two-dimensional array)

:::{.panel-tabset}

### Basics

+ A matrix is a collection of elements of the same data type. It consists of row and column (It's essentially a vector with additional dimension attribute).
+ I don't see matrix data structure in the real-world data. It is mainly used to do linear algebra operations.
+ `matrix()` function is used to create a matrix.

<br>

**Syntax**

```r
matrix(data = vector_data, nrow = number_of_rows, ncol = number_of_column, byrow = FALSE)
```

<br>

::: {.callout-note}
+ You need to specify the `vector_data` and the `number_of_rows` and `number_of_columns`.
+ If the length of `vector_data` is a multiple of `number_of_columns` (or `number_of_rows`), R will automatically figure how many rows (or columns) are needed.
+ As an option, you can specify `byrow = TRUE` to fill the matrix by row. By default, the value in `vector_data` is filled by column.
:::


### Example 1

```{webr-r}
# Create a numeric matrix
m_num <- matrix(1:6, nrow = 3)
m_num

# use dim() to see the dimension of the matrix
dim(m_num)

# Create a matrix of characters
m_chr <- matrix(c("a", "b" , "c", "d", "e", "f"), nrow = 3)
m_chr
```

### Example 2

You can also create a matrix by combining multiple vectors using `cbind()` or `rbind()` functions.

+ `rbind()` function combines vectors by row.
+ `cbind()` function combines vectors by column.


```{webr-r}
vec_a <- 1:4
vec_b <- 4:7

mat1 <- cbind(vec_a, vec_b)
mat1

mat2 <- rbind(vec_a, vec_b)
mat2
```

:::


## Matrix: How to Manipulate?

<!-- start panel:how to manipulate matrix   --> 
:::{.panel-tabset} 

### Indexing

Again, you can access the elements of a matrix using `[]` brackets. But now you have options to specify the row and column index.

**Example**

```{webr-r}
# --- Create a matrix of numbers --- #
m_num <- matrix(1:6, nrow = 3)
m_num

# --- Get the elements in the 1st row and 2nd column --- #
m_num[1, 2]

# --- Get the 1st row --- #
m_num[1, ]

# --- Get the the first two rows --- #
m_num[1:2, ]

# --- Modify a specific element --- #
m_num[1, 2] <- 100
m_num
```

### Miscellaneous

You can add column names and row names to a matrix using `colnames()` and `rownames()` functions. If a matrix has column names and row names, you can use the names as the index.

```{webr-r}
# Create a matrix of numbers
m_num <- matrix(1:6, nrow = 3)

# Add column names
colnames(m_num) <- c("A", "B")
m_num
# Add row names
rownames(m_num) <- c("a", "b", "c")

# --- Get the value of row "c" and column "B"  --- #
m_num["c", "B"]
```
 
<!-- end panel:how to manipulate matrix  --> 
:::

## Matrix: Exercise Problem (Optional)

Use the following matrix:

```{webr-r}
set.seed(3746)
num <- runif(n = 30, min = 0, max = 1)
mat <- matrix(data = num, nrow = 6)
colnames(mat) <- c("A", "B", "C", "D", "E")
rownames(mat) <- c("a", "b", "c", "d", "e", "f")
mat # see what's inside mat
```


1. Get the element in the 2nd row and 3rd column.
2. Get the 2nd row.
3. Subset the rows where column "A" is larger than 0.5. (Use logical indexing).

<br>

```{webr-r}
# Write your code here

```

```{r}
#| include: false
#| eval: false

vec_index <- mat[,"A"] > 0.5
mat[vec_index,]
```


## Data Frame

:::{.panel-tabset}

### Basics

+ `data.frame` class object is like a matrix but it can store any types of data in each column.
+ It is optimized for tabular data. That's why we see this data structure in the real-world data.

**Syntax**

```r
data.frame(column_1 = vector_1, column_2 = vector_2)
```

**Example**
```{webr-r}
# create a data.frame 
yield_data <- 
  data.frame(
    N = c(200, 180, 300),
    Yield = c(240, 220, 230),
    State = c("Kansas", "Nebraska", "Iowas")
  )
yield_data
```

If column name are not provided, R will assign column names to those columns automatically.

### Indexing

Again, you can access the elements of a data.frame using `[]` brackets. But you need to specify the row and column index like you did in the matrix.

As an index vector, you can use a vector of logical values, column names, and positional index.

```{webr-r}
# Get the elements in the 1st row 
yield_data[1, ]

# Get the element in the Nitrogen and Yield column
yield_data[, c("Yield", "N")] #or yield_data[1, "Yield"]

# Find states whose yield is more than 225
yield_data[yield_data$Yield > 225, "State"] # yield_data$Yield > 225 returns a logical vector
```


### $ and [[]] operator

You can also get a specific column values using `$` or `[[]]` operator.  

+ `$` and `[[]]` can only select one a single and return as a vector, whereas `[]` can select multiple columns ((see `?"$"`, `?"["` and `?"[["` about the difference in those operators). 

+ Inside `[[]]` you provide the column name as character.

+ Why we need this? As you'll see later, vector data is the most common input data structure when doing basic linear algebra in R (mean, sum, sqrt, etc.). (and it's the most fastest way to do the calculation in R!)

<br>

```{webr-r}
yield_data[["Yield"]] #returns a vector

yield_data$Yield #returns a vector
```

### Adding and Removing Columns

You can add a new column to a data.frame using the `$` operator.

**Syntax**
```r
data_frame$new_column <- vector_data
```
+ `vector_data` to be added must have the same length as the number of rows in the data.frame, otherwise the value is recycled.

<br>


```{webr-r}
yield_data$year <- c(2020, 2021, 2022)

yield_data$year<- 2021
yield_data$month<- "August"

# --- Remove the year column --- #
yield_data$month <-  NULL
```



### Miscellaneous

```{webr-r}
# column names
names(yield_data) #or colnames(yield_data)

# Change the column names to lower case
names(yield_data) <- tolower(names(yield_data))
yield_data
```
:::


## Exercise Problem

We will use the built-in dataset `mtcars` for this exercise. Run the following code to load the data.

```{webr-r}
# --- Load data --- #
data(mtcars)
?mtcars # to see the description of the yield_data

# --- Take a look at the data --- #
# head() function shows the first several rows of the data
head(mtcars)
```


1. Extract the rows corresponding to the cars with the row numbers 1, 5, and 10 using numeric indexing

2. Add a new column to the `mtcars` data frame called `power_to_weight_ratio`, which is calculated as the ratio of horsepower (`hp`) to weight (`wt`).

3. Create a new data frame called `efficient_cars` that contains cars with `mpg` greater than `20` and power-to-weight ratio less than 5.

4. (Optional) Sort the efficient_cars data frame by the `power_to_weight_ratio` column in ascending order and display the result. [Hints: (1)use `order()` function to sort the data frame. (2) Use `order(efficient_cars$power_to_weight_ratio)` as an index vector.]


```{webr-r}
# Write your code here

```


## with() and within()

`with()` and `within()` functions are useful when you want to do some operation on a data.frame.

+ `with(data_frame, function(column1))` function allows you to evaluate an expression in the context of a `data.frame`.

+ `within()` function is similar to `with()`, but it allows you to modify the `data.frame` in place.

[With these function, you can avoid typing the data frame name and `$` mark, repeatedly.]{style="color:red;"}


**Example**

```{webr-r}
# --- Plot --- #
plot(x = as.factor(yield_data$state), y = yield_data$yield)

# instead, you can do:
with(yield_data, plot(x = as.factor(state), y = yield))

with(yield_data, mean(yield)) # same as mean(yield_data$yield)

# --- Add multiple columns --- #
yield_data$year <- c(2020, 2021, 2022)
yield_data$season <- c("spring", "summer", "fall")

# instead, you can do
new_yield_data <- within(yield_data, {
  year <- c(2020, 2021, 2022)
  season <- c("spring", "summer", "fall")
})
```


## List

<!-- start panel:list   --> 
:::{.panel-tabset} 
### Basics

+ A list in R can store elements of different types and sizes, including numbers, characters, vectors, matrices, data frames, and even other lists. 


+ A `list` is a collection of data that can have any data and data structure types as its element. You can create a list using `list()` function.


```{webr-r}
list_a <- list(1, 2, "3", 4)
list_a

# You can even store `data.frame` in a list.
example_list <- 
  list(
    num = 1:4,
    yield_dt  = yield_data
  )
```

### Indexing

You can access list elements using `$` amd `[]` or `[[]]` brackets. 

+ `[]` and returns **a list** of the selected elements. 
+ `[[]]` and `$` returns any single element as it is. `$` can be used only when the list has names.


```{webr-r}
# note: yield data has two elements: num (vector) and yield_dt (data.frame)

# --- Return as a list of element --- #
example_list[1] #same as example_list["num"]
example_list[2] #same as example_list["num"]

# --- Return as a single element --- #
example_list[[1]] # same as example_list$num
example_list[[2]] # same as example_list$yield_dt
```
 



:::{.notes}
+ Generally, 
  + [[]] returns the selected element with the same class as the original object. 
  + 
+ This behavior is consistent with what we saw in the `data.frame` class object.
+ In `data.frame` each element, 
  + `[]` returns a `data.frame` object of the selected elements (column)
  + `[[]]` returns any single element which is a column vector, because each column is made of a vector. 
:::

<!-- end panel:list  --> 
:::

## Summary {.center}

Here are the key points I want you to know at least:

::: {.callout-important}
## Key Points
+ To know that how to create vector, matrix, data.frame, and list object in R.
  + Vector and matrix stores the same data type, whereas data.frame and list can store different types of data.
+ To access and subset and modify the elements of the object, use indexing (logical, positional, and named).
  + For indexing, you can use `[]`, `$`, and `[[]]` operators.
:::


<!-- ::: {.callout-tip}
## Supplement: Advanced Technical Details
+ While list and data.frame can store different types of data, they are less efficient than vector and matrix, because of the amount of information they store. So, vectorized 
::: -->


# Matrix/Linear Algebra in R

---

:::{.panel-tabset}
### Basic arithmetics

For the calculation of remainder and quotient, you don't need to remember the operator. 

```{webr-r} 
#--- addition ---#
2 + 3
#--- subtraction ---#
6 - 2
#--- multiplications ---#
6 * 2
#--- exponentiation ---#
2 ^ 3
#--- division ---#
6 / 2
#--- remainder ---#
9 %% 4
#--- quotient ---#
9 %/% 4
```




### Vector calculation

Arithmetic operations of vectors are performed by element-wise (element by element in the same position).


```{r}
a <- c(1, 3, 2)
b <- c(5, 7, 6)

# --- Addition --- #
a + 1
a + b

# --- Subtraction --- #
a - 1
b - a

# --- Multiplication --- #
a*2
a*b
```


### Matrix calculation

If you want to do matrix multiplication, you need to use `%*%` operator. Otherwise, it will be element-wise multiplication.

```{webr-r}
mat_a <- matrix(1:4, nrow = 2)
mat_b <- matrix(4:7, nrow = 2)


#--- Matrix Addition and Subtraction ---#
mat_a + mat_b
mat_b - mat_a

# --- Matrix Multiplication using %*% operator --- #
mat_a %*% mat_b

mat_a * mat_b # element-wise multiplication

# --- Matrix Transpose --- #
t(mat_a)
```
:::




# Loading and Saving Data


---

## R base functions for data import and export


+ Like other softwares (e.g., Stata, Excel) do, R has two native data formats: `.Rdata` (or `.rdata`) and `.Rds` (or `.rds`) 
  + `.Rdata` is used to save multiple R objects, 
  + `.Rds` is used to save a single R object


<br>

:::: {.columns}
::: {.column width="50%"}
**.Rdata** format

+ Load data: 

```load("path_to_Rdata_file")```

+ Save data: 

```save(object_name, file = "path_to_Rdata_file")```
:::


::: {.column width="50%"}
**.Rds** format

+ Load data: 

```readRDS("path_to_Rds_file")```

+ Save data: 
  
```saveRDS(object_name, file = "path_to_Rds_file")```
:::
::::



:::{.notes}
+ An rds ( r data set) file is a file type that is supported by R.
:::



## Setting the working directory

:::{.panel-tabset}

### Basics

[To access to the data file, you need to provide the path to the file (the location of the data file).]{style="color:red;"}

<br>

**Example** 

Suppose that I want to load `flight.rds` in the Data folder. On my computer, the full path (i.e., absolute path) to the file is `/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data/flight.rds`.

```{r}
#| eval: false
# this code only works in my local machine
flight_dt <- readRDS(file = "/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data/flight.rds")
```

<br>

::: {.callout-caution}
## Problems
1. I do not want to type the full path every time I load the data. It's too cumbersome.
2. If you are working with a team, your code might not work for other person because the path to the data file is different for each person.
:::



### Working Directory

+ **Working Directory** is a file path on your computer where R looks for files that you ask it to load, and where it will put any files that you ask it to save.
  + You can check the current working directory using `getwd()` function.
  + By default, R (`.R` file) uses your home directory as the working directory.

```{r}
#| eval: false
# On your Rsdutio, run the following code
getwd() #wd stands for working directory
# In my case, this returns my home directory: "/Users/shunkeikakimoto"
```


### setwd()
+ If you expect to import and/or export (save) datasets and R objects often in that particular directory, it would be nice to tell R to look for files in the directory by default.
+ You can use `setwd()` to designate a directory as the working directory:

**Example 1**

In my case, I set the working directory to the `Data` folder. 

```{r}
#| eval: false
setwd("/Users/shunkeikakimoto/Dropbox/git/R_summer_2024/Data")
```

Now, R will look for the data file in the `Data` folder by default. So, I can load the data using *relative path*, not *absolute path*.

```{r}
#| eval: false
flight_dt <- readRDS(file = "flight.rds")
```

<br>

:::{.fragment .fade-up}
::: {.callout-caution}
## Problems
+ Still, `setwd()` relies on an absolute file path, which might vary by person (e.g., some person save folder in Dropbox, other person uses Google Drive). 
+ So, designating working directory using `setwd()` does not solve the second problem completely (i.e, If you are working with a team, the path to the data file is different for each person.)
:::
:::


### R project

:::{.panel-tabset}

### What is it?

> "R experts keep all the files associated with a project together — input data, R scripts, analytical results, figures. This is such a wise and common practice that RStudio has built-in support for this via **projects**." - [R for Data Science Ch 8.4](https://r4ds.had.co.nz/workflow-projects.html?q=working%20directory#rstudio-projects)

<br>

::: {.callout-caution}
## RStudio Projects

+ An RStudio project is a way to organize your work.

+ Once R project is loaded, it automatically sets current working directory to the folder where that `.Rproj` file is saved (you don't need `setwd()`!).

+ As long as the folder structure in the project folder is the same (relative path from the folder containing `.Rproj` file), you can share the code involving data loading with your team members.
:::



### Let's create a project!

Follow this steps illustrated in this document: [R for Data Science Ch 8.4](https://r4ds.had.co.nz/workflow-projects.html?q=working%20directory#rstudio-projects)

### Load the data

+ On your Rstudio, check the top-right corner of the Rstudio window. You will see the name of the project you created.
  + Alternatively, you can open the project by clicking the `.Rproj` file via Finder (Mac) or File Explorer (Windows).

+ Now, let's check the current working directory using `getwd()` function. You will see the path to the project folder.
+ Let's load `flight.rds` data file with `readRDS()` function.
:::

:::


## Loading the data other than .Rds (.rds) format

<!-- start panel:loading data   --> 
:::{.panel-tabset} 
### Basics

+ R can load data from various formats including `.csv`, `.xls(x)`, and`.dta`.
+ There exists many functions that can help you to load data:
  + `read.csv()` to read a `.csv` file
  +  `read_excel()` from the `readxl` package to read data sheets from an `.xls(x)` file
  + `read.dta13()` function from the `readstata13` package to read a STATA data file (`.dta`)


::: {.callout-important}
## Use import() function
+ **But** `import()` function from the `rio` package might be the most convenient one to load various format of data. 
  + Unlike, `read.csv()` and `read.dta13()` which specialize in reading a specific type of file, `import()` can load data from various sources.
:::

### Let's do it

In `Data` folder, `flight` data is saved with three different formats: `flight.csv`, `flight.dta`, and `flight.xlsx`. Let's load the data using `import()` function on your Rstudio.

```{webr-r}
# If you don't have the rio package, install it by running the following code:
# install.packages("rio")
library(rio)
``` 
 
<!-- end panel:loading data  --> 
:::



## Saving the data

+ You can save the data with various format.
+ **But**, Unless necessary, it is recommended to save the data in `.rds` format.
  + how?: `saveRDS(object_name, path_to_save)`

<br>

**Reasons**
+ If you work with R, there is no reason to save the data in other format than `.rds`.
+ `.rds` format is more efficient in terms of saving and loading the data.
  + Check the size of the `flight` data files in different formats. Which one is the smallest?

<br>

Let's try!

+ Load the `flight` data in the `Data` folder.
+ Subset 

```{webr-r}
flights <- readRDS("Data/flight.rds")
```

## Summary {.center}

:::{.callout-important}
+ Rstudio project (`.Rproj`) is a useful to organize your work. As long as the folder structure under the `.Rproj` is the same, you can share the code involving data loading with your team members.
+ To lode data:
  + use `readRDS()` function for `.Rds` (`.rds`) format.
  + you can use `import()` function from the `rio` package for various format.
+ To save the data, it is recommended to use `.rds` format and use `saveRDS()` function.
:::


# Exercise Problems
<!-- create a problem related to vector and data.frame -->


## Exercise Problems 1: Vector

:::{.panel-tabset}

### Problems

<!-- From this [website](https://www.w3resource.com/r-programming-exercises/) -->

1. Create a sequence of numbers from 20 to 50 and name it `x`. Let's change the numbers that are multiples of 3 to 0.

2. `sample()` is commonly used in Monte Carlo simulation in econometrics. Run the following code to create `r`. What does it do? Use `?sample` to find out what the function does.

```{webr-r}
#| autorun: true
setwd(12345) #don't worry about this
r <- sample(1:100, size=20, replace = TRUE)
```

3. Find the value of mean and SD of vector `r` without using `mean()` and `sd()`
4. Figure out which position contains the maximum value of vector `r`. (use `which()` function. Run `?which()` to find out what the function does.)
5. Extract the values of `r` that are larger than 50.
6. Extract the values of `r` that are larger than 40 and smaller than 60.
7. Extract the values of `r` that are smaller than 20 or larger than 70.


### Answers

```{webr-r}
# === Part 1 === #
x <- 20:50
# using `:` operator is the most basic way to create a sequence of numbers, but it only works with integer numbers with a step of 1.
# seq() function is more flexible. For example, you can create a sequence of numbers, , incremented by 0.5.
# x <- seq(from = 20, to = 50, by = 0.5)
x[x %% 3 == 0] <- 0

# === Part 2 === #
# In this code, sample() function creates a random sample of numbers with size 20 (size=20) from a range 1 to 100 (x = 1:100) allowing replacement (replace = TRUE).

# === Part 3 === #
# mean
mean_r <- sum(r) / length(r)
# SD
sd_r <- sqrt(sum((r - mean_r)^2) / (length(r) - 1))

# === Part 4 === #
max_index <- which(r == max(r))

# === Part 5 === #
r_50 <- r[r > 50]

# === Part 6 === #
r_40_60 <- r[r > 40 & r < 60]

# === Part 7 === #
r_20_70 <- r[r < 20 | r > 70]
```
:::


## Exercise Problem 2: Data Frame
  

:::{.panel-tabset}

### Problem 

<!-- I adapted the following problem from the in-class exercise of the course Programming for Econometrics (APEC 8221). -->

<br>

1. Load the file `nscg17small.dta`. You can find the data in the `Data` folder. 
   + This data is a subset of the National Survey of College Graduates (NSCG) 2017, which collects data on the educational and occupational characteristics of college graduates in the United States.

2. Each row corresponds to a unique respondent. Let's create a new column called "ID". There are various ways to create an ID column. Here, let's create an ID column that starts from 1 and increments by 1 for each row.
3. Get the descriptive statistics of the salary (use `summary()` function).
4. Create a new variable in your data that represents the z-score
of the hours worked (use `hrswk` variable).
$$Z = (x - \mu)/\sigma$$
, where $Z = \text{standard score}$, $x =\text{observed value}$, $\mu = \text{mean of sample}$, and $\sigma = \text{standard deviation of the sample}$.
1. Calculate the share of observations in your data sample with
above average hours worked.


### Answer

```{webr-r}
# === Part 1 === #
nscg17 <- rio::import("Data/nscg17small.dta")

# === Part 2 === #
nscg17$ID <- 1:nrow(nscg17)

# === Part 3 === #
summary(nscg17$salary)

# === Part 4 === #
nscg17$z_hrswk <- (nscg17$hrswk - mean(nscg17$hrswk)) / sd(nscg17$hrswk)
# or using with() function, you can write the code more concisely
# nscg17$z_hrswk2 <- with(nscg17, (hrswk - mean(hrswk)) / sd(hrswk))

# Note: For part 2 and 3, you can use within() function to create new columns more concisely.
# nscg17 <- 
#   within(
#     nscg17, {
#       ID <- 1:nrow(nscg17)
#       z_hrswk <- (hrswk - mean(hrswk)) / sd(hrswk)
#     }

# === Part 5 === #
# create a logical vector that indicates whether the hours worked is above average
above_avg_hrswk <- with(nscg17, z_hrswk > mean(z_hrswk)) # you can get the same result by using `hrswk`.
# subset the data
nscg17_above_avg_hrswk <- nscg17[above_avg_hrswk, ]
# calculate the share of observations with above average hours worked
share_above_avg_hrswk <- nrow(nscg17_above_avg_hrswk) / nrow(nscg17)
share_above_avg_hrswk
```
:::

## Exercise Problems 3 (Advanced)
:::{.panel-tabset}

### Problem

Let's use `flight.rds` data in the `Data` folder. Load the data. We will only look at the flights data with "MSP" (Minneapolis–Saint Paul International Airport) as the destination airport. 

[For each airline company (`carrier`), find the proportion of flights that are delayed more than 30 minutes.]{style="color: blue;"}

<br>

::: {.callout-note}
+ You can solve this exercise problem by using only base-R functions. See Hints if you need help.
+ Also, note that googling is one of the most important skills for coding!
:::


### Hints (step by step)

Here are the steps that I took to solve the problem. You do not need to follow the steps.

1. Load the `flight.rds` data in the `Data` folder.
2. Select the columns `year`, `month`, `day`, `dep_delay`, `arr_delay`, `dest`, and  `carrier`, and subset rows that have "MSP" as `dest`. Let's name the data `flights_mn`.
3. In `flights_mn`, create a new column called `total_delay` which is the sum of `dep_delay` and `arr_delay`. Further, create a new column called `delay_type` which takes character `"delay_more_30"` if `total_delay` is more than 30 minutes, and character `"others"` (or 0) otherwise.
   + You can use `ifelse()` function to create a binary variable, `delay_type`.

4. Count the binary category `delay_type` by `carrier`. Let's name the result `flights_mn_delay_count`.
   + `table()` is an R base function to create frequency table. For example, `table(data$x)` creates a frequency table of `x` in the data. `table(data$x, data$y)` creates a frequency table of each combination of `x` and `y` in the data.
   + After you create the table, translate the `table` to `data.frame` class using `as.data.frame.matrix()` function to make it easier to manipulate.
5. Finally, in `flights_mn_delay_count`, derive the proportion of flights that are delayed more than 30 minutes for each airline company.


### Answers

There are multiple ways to solve the problem. Here is one of the possible solutions.

```{webr-r}
#| eval: false
# === Step 1: Load data === #
# flights <- readRDS("Data/flight.rds")
# the data is created with the following code:
flights <- nycflights13::flights
flights <-  na.omit(flights)
flights <-  as.data.frame(flights)

# === Part 2: subset data === #
# define the columns to select
select_cols <- c("year", "month", "day", "dep_delay", "arr_delay", "dest", "carrier")
flights_mn <- flights[flights$dest == "MSP", select_cols]

# === Part 3: Create total_delay and delay_type === #
# the most basic approach is 
flights_mn$total_delay <- flights_mn$dep_delay + flights_mn$arr_delay
flights_mn$delay_type <- 
  ifelse(flights_mn$total_delay>30, "delay_more_30", "others")

# alternatively, you can use within() function like this:
flights_mn <- within(
  flights_mn, {
    total_delay <- dep_delay + arr_delay
    delay_type <- ifelse(flights_mn$total_delay>30, "delay_more_30", "others")
  }
)

# === Part 4: count === #
flights_mn_delay_count <- table(flights_mn$carrier, flights_mn$delay_type)
# same as
flights_mn_delay_count <- with(flights_mn, table(carrier, delay_type))
# translate the table to data.frame class to make it easier to manipulate
flights_mn_delay_count <- as.data.frame.matrix(flights_mn_delay_count)


# === Part 5: derive proportion of flights delayed more than 30 mins === #
# I will only show the code using within() function
flights_mn_delay_count <- within(
  flights_mn_delay_count,
  {
    total_flights <- others + delay_more_30
    prop_more_30 <- delay_more_30 / total_flights
  }
)
flights_mn_delay_count
```
:::


## A List of Useful R Built-in Functions

<!-- start panel:functions   --> 
:::{.panel-tabset} 
### For data manipulation


| Function                  | Description                                                                     |
|---------------------------|---------------------------------------------------------------------------------|
| `length()`                | get the length of the vector and list object                                                    |
| `nrow()`,` ncol()`        | get the number of rows or columns                                               |
| `dim()`                   | get the dimension of the data                                                   |
| `rbind()`,` cbind()`      | Combine R Objects by rows or columns                                            |
| `colMeans()`, `rowMeans()`| calculate the mean of each column or row                                        |
| `with` and `within()`     | You don't need to use `$` every time you access to the column of the data.frame.|
| `ifelse()`                | create a binary variable                                                        |
| `paste()`, `paste0()`     | concatenate strings                                                             |

<br>

### For numerical manipulation
| Function                                   | Description                                           |
|--------------------------------------------|-------------------------------------------------------|
| `sum(), mean(), var(), sd(), cov(), cor(), max(), min(), abs(), round()`|                                                       |
| `log()` and `exp()`                        | Logarithms and Exponentials                           |
| `sqrt()`                                   | Computes the square root of the specified float value.|
| `seq()`                                 | Generate a sequence of numbers                      |X
| `sample()`                                 | randomly sample from a vector                         |X
| `rnorm()`                                  | generate random numbers from normal distribution      |
| `runif()`                                  | generate random numbers from uniform distribution   |
 
 
 
<!-- end panel:functions  --> 
:::
